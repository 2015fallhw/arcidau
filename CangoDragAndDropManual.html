<!DOCTYPE HTML>
<html>
<head>
  <title>Cango Axes Module User Guide</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="keywords" content="canvas graphics, plotting graphs with canvas, Cango, Cango extension, canvas graphics library" />

  <link rel="stylesheet" href="2ColStickyScroll-14.css" media="all" type="text/css" />
  <style type="text/css" media="screen">
    @import "contentStyle-18.css";

    .cvsEg {
      position: relative;   /* positioned to parent bottom menus */
      display: block;       /* must have for position canvas elements */
      margin: 20px auto;
      padding: 0;
      background-color: lightyellow;
      border: 1px solid black;
    }
  </style>

  <script type="text/javascript">
    var sidebar = null,
        sidebar_top = 100;

    if (typeof addLoadEvent === "undefined")
    {
      var addLoadEvent = function(func)
      {
      	var oldonload = window.onload;
      	if (typeof window.onload != 'function')
        {
          window.onload = func;
        }
      	else
        {
        	window.onload = function(){oldonload();	func();}
        }
      }
    }

    if (typeof addEvent === "undefined")
    {
      var addEvent = function(element, eventType, handler)
      {
        if (element.attachEvent)
        {
          return element.attachEvent('on'+eventType, handler);
        }
        return element.addEventListener(eventType, handler, false);
      };
    }

    function cancelBubble(e)
    {
      var evt = e ? e:window.event;
      if (evt.stopPropagation) evt.stopPropagation();
      if (evt.cancelBubble!=null) evt.cancelBubble = true;
    }

    /* -------------------------------------------------------------------------
     * buildMenu(dataArray)
     *
     * dataArray should be in JSON format as follows
     * [ {"url":"url of file", "title":"String to display in index"},
     *   {"url":"url of file", "title":"String to display in index",
     *    "chapters": [
     *       {"url":"url of file", "title":"String to display in index"},
     *       {"url":"url of file", "title":"String to display in index"},
     *       ...
     *       {"url":"url of file", "title":"String to display in index"}
     *     ]
     *   },
     *   {"url":"url of file", "title":"String to display in index"},
     *   ...
     * ]
     * Then build HTML anchors from the array.
     *--------------------------------------------------------------------------*/
    function buildMenu(dataArray)
    {
      var menuNode = document.getElementById("sideNav"),
          htmlStr = "",
          currPage,
          i;

      function subStringReplaceAt(str, index, newSubStr, oldSubStrLength)
      {
        return str.slice(0, index) + newSubStr + str.slice(index+oldSubStrLength);
      }

      function parseAry(obj)
      {
        var currPage = document.URL.replace(/^.*[\\\/]/, ''),   // split off the page name (cross platform)
            i;
        for (i=0; i<obj.length; i++)
        {
          if (obj[i].chapters)
          {
            htmlStr += "<ul>";
            htmlStr += "<li class='sectClosed'><input type='button' onclick='toggleSection(this)' value='"+obj[i].title+"'><ul class='options'>";
            parseAry(obj[i].chapters);
            htmlStr += "</ul></li>";
          }
          else
          {
            htmlStr += "<li><a href='"+obj[i].url+"' target='_top'>"+obj[i].title+"</a></li>";
            // check if this index entry is the current page, if open this section to show link
            if (currPage == obj[i].url)
            {
              htmlStr = subStringReplaceAt(htmlStr, htmlStr.lastIndexOf("sectClosed"), "sectOpen", 10);
            }
          }
        }
      }

      parseAry(dataArray);
      menuNode.innerHTML += htmlStr;
    }

    function toggleSection(btn)
    {
      if (btn && btn.parentNode.className === "sectClosed")
      {
        btn.parentNode.className = "sectOpen";
      }
      else if (btn && btn.parentNode.className === "sectOpen")
      {
        btn.parentNode.className = "sectClosed";
      }
      return false;   // is used with anchor will prevent going to href
    }

    function enableStickyNav()
    {
      var stickyElements = document.getElementsByClassName('sticky');

      for (var i = stickyElements.length - 1; i >= 0; i--) {
          Stickyfill.add(stickyElements[i]);
      }
    }
  </script>

<!-- 'indexNested.js' defines the global 'var indexData' holding menu entries  -->
  <script type="text/javascript" src="indexNested.js"></script>
  <script src="stickyfill.js"></script>

  <script type="text/javascript" src="Cango-8v03-min.js"></script>
  <script type="text/javascript" src="CangoDragAndDrop-2v00.js"></script>
  <script type="text/javascript" src="KnobRpg-3v00.js"></script>

  <script type="text/javascript">
    if (typeof addLoadEvent === "undefined")
    {
      var addLoadEvent = function(func)
      {
      	var oldonload = window.onload;
      	if (typeof window.onload != 'function')
        {
          window.onload = func;
        }
      	else
        {
        	window.onload = function(){oldonload();	func();}
        }
      }
    }
  </script>

  <script type="text/javascript">
    function editCurve(cvsID)
    {
      "use strict";

      var x1 = 40, y1 = 10,
          cx1 = 90, cy1 = 60,
          x2 = 120, y2 = 50,
          cx2 = 130, cy2 = 10,
          cx3 = 150, cy3 = 60,
          x3 = 180, y3 = 30,
          c1, c2, c3,
          drawCurve,
          dragC1, dragC2, dragC3,
          g = new Cango(cvsID);

      dragC1 = function(mousePos)    // called in scope of DnD obj
      {
        cx1 = mousePos.x;
        cy1 = mousePos.y;
        drawCurve();
      };

      dragC2 = function(mousePos)
      {
        cx2 = mousePos.x;
        cy2 = mousePos.y;
        drawCurve();
      };

      dragC3 = function(mousePos)
      {
        cx3 = mousePos.x;
        cy3 = mousePos.y;
        drawCurve();
      };

      drawCurve = function()
      {
        var data1 = ['M', x1, y1, 'Q', cx1, cy1, x2, y2],
            data2 = ['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3],
            dashLine;

        g.clearCanvas();
        // curve change shape so it must be re-compiled each time
        // draw a quadratic bezier from x1,y2 to x2,y2
        g.drawPath(data1, 0, 0, {strokeColor:'blue'});
        g.drawPath(data2, 0, 0, {strokeColor:'green'});
        // show lines to control point
        dashLine = new Cobj(['M', x1, y1, 'L', cx1, cy1, x2, y2], "PATH", {
          strokeColor:'blue',
          dashed:[4] });
        g.render(dashLine);
        dashLine = new Cobj(['M', x2, y2, 'L', cx2, cy2], "PATH", {
          strokeColor:'green',
          dashed:[4]});
        g.render(dashLine);
        dashLine = new Cobj(['M', x3, y3, 'L', cx3, cy3], "PATH", {
          strokeColor:'green',
          dashed:[4] });
        g.render(dashLine);
        // draw draggable control points
        g.render(c1, cx1, cy1);
        g.render(c2, cx2, cy2);
        g.render(c3, cx3, cy3);
      };

      g.setGridboxRHC();
      g.fillGridbox("lightyellow");
      g.setWorldCoords(0, 0, 200, 70);

      // pre-compile the draggable control point
      c1 = new Cobj(shapeDefs.circle(6), "SHAPE", {fillColor:'red'});
      c1.enableDrag(null, dragC1, null);
      c2 = new Cobj(shapeDefs.circle(6), "SHAPE", {fillColor:'red'});
      c2.enableDrag(null, dragC2, null);
      c3 = new Cobj(shapeDefs.circle(6), "SHAPE", {fillColor:'red'});
      c3.enableDrag(null, dragC3, null);

      drawCurve();
    }

//==============================================================

    function simpleKnob(cvsID)
    {
      "use strict";

      var ptrCmds, ptr, base, knob,
          grabOfsAng = 0,
          gc = new Cango(cvsID);

      function knobGrab(mousePos)
      {
        var csrX = mousePos.x - this.dwgOrg.x,
            csrY = mousePos.y - this.dwgOrg.y;
        grabOfsAng = Math.atan2(csrY, csrX);
      }

      function knobDrag(mousePos)
      {
        var csrX = mousePos.x - this.dwgOrg.x,
            csrY = mousePos.y - this.dwgOrg.y,
            angle = Math.atan2(csrY, csrX) - grabOfsAng;

        gc.clearCanvas();
        gc.render(knob, 0, 0, 1, 180*angle/Math.PI);
      }

      gc.clearCanvas();
      gc.setGridboxRHC();
      gc.setWorldCoords(-5, -5, 10);   // isotropic coords
      // make knob index marker line with lineWidth = 8
      ptrCmds = ['M', 1.2, 0, 'L', 2.5, 0];
      ptr = new Cobj(ptrCmds, "PATH", {strokeColor:'black', lineWidth:8});
      // make circular knob
      base = new Cobj(shapeDefs.circle(5), "SHAPE", {
        fillColor:'gold',
        border: true,
        strokeColor:'gray',
        lineWidth: 2,
        shadowOffsetX:0.1,
        shadowOffsetY:-0.2,
        shadowBlur:0.1,
        shadowColor:"#303030" });
      // enable Drag and Drop on the knob
      base.enableDrag(knobGrab, knobDrag, null);
      // save the components in knob array of Obj
      knob = [base, ptr];
      gc.render(knob);
    }

//==================================================================================

    function Counter(gc, x, y, numChars, fontSize)
    {
      var savThis = this,
          roOrgX = x || 0,       // this is where lower,right corner of TEXT is positioned
          roOrgY = y || 0,
          pxSize = fontSize || 18,
          size = pxSize/gc.xscl,    // make readout scale with font size
          nChar = numChars || 5,
          // draw a readout panel (dimension relative to char size)
          outline = ['M', 0.4, -0.3, 'l', 0, 1.7, -1.0*nChar, 0, 0, -1.7, 'z'],
          panel, strObj, total = 0;

      this.fgColor = '#ff3000';      // support dynamic foreground and background colors
      this.bgColor = '#405040';
      panel = new Cobj(outline, "SHAPE", {fillColor: this.bgColor, border: true, strokeColor:'gray'});
      panel.scale(size);
      strObj = new Cobj("", "TEXT", {"fillColor":savThis.fgColor, "fontSize":pxSize, "lorg":9, fontWeight:700});
      gc.render([panel,strObj], roOrgX, roOrgY);   // draw the blank readout

      this.updateCounter = function(pulses)   // callBack for rotary pulse generator
      {
        total += pulses;
        panel.setProperty("fillColor", savThis.bgColor);
        strObj.drawCmds = total.toString();
        strObj.setProperty("fillColor", savThis.fgColor);
        gc.render(panel, roOrgX, roOrgY);   // clear old value
        gc.render(strObj, roOrgX, roOrgY);
      }
      this.updateCounter(0);
    }

    function initKnob(cvsID)
    {
      var xmin = 0, xspan = 400,       // x scale sets the knob size
          ymin = 0, yspan = 150,
          ro, bigKnob,
          g = new Cango(cvsID),
          ovlGC;

      g.clearCanvas("#aaaaba");   // clearout _draggables
      g.deleteAllLayers();
      g.setWorldCoords(xmin, ymin, xspan, yspan);

      ro = new Counter(g, 150, 110, 5, 22);

      ovlGC = new Cango(g.createLayer());
      ovlGC.dupCtx(g);
      bigKnob = new KnobRpg(ovlGC, 250, 60, 150, 90, ro.updateCounter);
    }

//--------------------------------------------------------------------------------------

    function zoomPanTest(cvsID)
    {
      'use strict';
      var g,
          gL1,
          xmin = -300,
          ymin = -200,
          xspan = 750,
          Arc3 = "M0,50 h-150 a150,150 0 1,0 150,-150 z M-25,25 v-150 a150,150 0 0,0 -150,150 z",
          ro, jane, txt, arcsObj;

      g = new Cango(cvsID);
      g.setGridboxRHC();
      g.setWorldCoords(xmin, ymin, xspan);

      gL1 = new Cango(g.createLayer());
      gL1.dupCtx(g);

      jane = new Cobj("Images/JaneAvril2.jpg", "IMG", {
        imgHeight: 140,
        border:true,
        lineWidthWC:6,
        strokeColor:'sienna',
        shadowOffsetX:8,
        shadowOffsetY:-8,
        shadowBlur:4,
        shadowColor:'grey' });
      g.render(jane, 100, 200);

      txt = new Cobj("Caption", "TEXT", {fillColor:"red", fontSize:12});
      g.render(txt, 100, 40);

      arcsObj = new Cobj(svgToCgoRHC(Arc3), "SHAPE", {
        border:true,
        strokeColor:"red",
        lineWidth: 2,
        fillColor:"yellow" });
      gL1.render(arcsObj, 0,0, 0.5);

      function drawBits()
      {
        g.clearCanvas();
        g.render(jane, 100, 200);
        g.render(txt, 100, 40);
        gL1.clearCanvas();
        gL1.render(arcsObj, 0,0, 0.5);
      }

      initZoomPan(g.createLayer(), [g, gL1], drawBits);
    }

  </script>

  <script type="text/javascript">
    addLoadEvent( function(){
      buildMenu(indexData);

      editCurve('cgDrag');
      simpleKnob('cgKnob');
      initKnob('cgRPG');
      zoomPanTest('cgZP');

      enableStickyNav();
    });
  </script>

</head>

<body>
  <div id="headerBkg"></div>
  <div class="outer">
    <div class="header">
      <p class="banner" style="z-index:1">MISCELLANY</p>
       <p class="hdrBlurb">MISCELLANEOUS TECHNICAL ARTICLES BY <span style="letter-spacing: 1px;">Dr</span> A R COLLINS</p> 
      <div id="logoHolder" style="">
        <p class="banner inverse">MISCELLANY</p>
      </div>
      <div id="logo">
        <a class="logoText" href="index.htm"><b>arc</b><br/><span style="font-size:14px">.id.au</span></a>
      </div>
    </div>

    <div id="sideNavBkg"></div>
    <div id="sideNav" class="sticky">
      <!--
            filled by 'buildMenu()'
      -->
    </div>      <!-- sideNav -->

    <div id="page">
      <div id="content">
        <div class="h1Bkg"></div>
        <h1>Cango Drag and Drop Module User Guide</h1>
        <div class="text_01">

<h2>Cango Drag and Drop module</h2>
<p>The Cango Drag and Drop extension module, <a href="CangoDragAndDrop-2v00.js" download>CangoDragAndDrop-2v00.js</a> provides additional Cango library methods to enable user control of graphics object via mouse events. This extension adds the following methods to the <b>Cobj</b> object:</p>
<div style='margin-left:2em'>
<p><i>Cobj</i>.<a href="#enableDrag">enableDrag</a>(grabCallback, dragCallback, dropCallback)</p>
<p><i>Cobj</i>.<a href="#disableDrag">disableDrag</a>()</p>
</div>

<h2>Zoom and Pan Utility</h2>
<p>Version 2 of the CangoDragAndDrop module provides support for adding a zoom and pan capability to a Cango canvas stack. The zoom and pan controls are set up by calling the global function:</p>
<p><a href="#initzoompan">initZoomPan</a>(zpLayerId, gc, redraw)</p>

<h4>Drag and Drop Example</h4>

<p>Here is a simple example, which shows two Bézier curves with draggable control points.</p>

<canvas id="cgDrag" class="cvsEg" width="450" height="300"></canvas>

<div class="captionHolder" style="width: 450px">
  <p class="caption"><b>Figure 1.</b> Example of drag-n-drop on the red SHAPE objects.</p>
</div>  <!-- captionHolder -->

<p>The code for the curve editor in Fig. 1 is show below.</p>
<div class="srcFmt">
<pre>
function editCurve(cvsID)
{
  "use strict";

  var x1 = 40, y1 = 10,
      cx1 = 90, cy1 = 60,
      x2 = 120, y2 = 50,
      cx2 = 130, cy2 = 10,
      cx3 = 150, cy3 = 60,
      x3 = 180, y3 = 30,
      c1, c2, c3,
      drawCurve,
      dragC1, dragC2, dragC3,
      g = new Cango(cvsID);

  dragC1 = function(mousePos)    // called in scope of DnD obj
  {
    cx1 = mousePos.x;
    cy1 = mousePos.y;
    drawCurve();
  };

  dragC2 = function(mousePos)
  {
    cx2 = mousePos.x;
    cy2 = mousePos.y;
    drawCurve();
  };

  dragC3 = function(mousePos)
  {
    cx3 = mousePos.x;
    cy3 = mousePos.y;
    drawCurve();
  };

  drawCurve = function()
  {
    var data1 = ['M', x1, y1, 'Q', cx1, cy1, x2, y2],
        data2 = ['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3],
        dashLine;

    g.clearCanvas();
    // curve change shape so it must be re-compiled each time
    // draw a quadratic bezier from x1,y2 to x2,y2
    g.drawPath(data1, 0, 0, {strokeColor:'blue'});
    g.drawPath(data2, 0, 0, {strokeColor:'green'});
    // show lines to control point
    dashLine = new Cobj(['M', x1, y1, 'L', cx1, cy1, x2, y2], "PATH", {
      strokeColor:'blue',
      dashed:[4] });
    g.render(dashLine);
    dashLine = new Cobj(['M', x2, y2, 'L', cx2, cy2], "PATH", {
      strokeColor:'green',
      dashed:[4]});
    g.render(dashLine);
    dashLine = new Cobj(['M', x3, y3, 'L', cx3, cy3], "PATH", {
      strokeColor:'green',
      dashed:[4] });
    g.render(dashLine);
    // draw draggable control points
    g.render(c1, cx1, cy1);
    g.render(c2, cx2, cy2);
    g.render(c3, cx3, cy3);
  };

  g.setGridboxRHC();
  g.fillGridbox("lightyellow");
  g.setWorldCoords(0, 0, 200, 70);

  // pre-compile the draggable control point
  c1 = new Cobj(shapeDefs.circle(6), "SHAPE", {fillColor:'red'});
  c1.enableDrag(null, dragC1, null);
  c2 = new Cobj(shapeDefs.circle(6), "SHAPE", {fillColor:'red'});
  c2.enableDrag(null, dragC2, null);
  c3 = new Cobj(shapeDefs.circle(6), "SHAPE", {fillColor:'red'});
  c3.enableDrag(null, dragC3, null);

  drawCurve();
}
</pre>
</div>

<p>The Drag and Drop extension requires Cango canvas graphics library version 5 or later. The CangoDragAndDrop-2v00.js file should be loaded after the core Cango file. Typical header code is as follows:</p>

<div class="srcFmt" style="max-height:580px">
<pre>
&lt;!DOCTYPE HTML>
&lt;html>
&lt;head>
  &lt;title>Canvas Test&lt;/title>
  &lt;script type="text/javascript" src="Cango-8v02-min.js">&lt;/script>
  &lt;script type="text/javascript" src="CangoDragAndDrop-2v00.js">&lt;/script>

...
</pre>
</div>

<h3>Cango Drag and Drop architecture</h3>

<p>Drag and Drop can be enabled on any Cobj object by calling the <i>Cobj</i>.<b>enableDrag</b> method passing as parameters references to the 'grabHandler', 'dragHandler' and 'dropHandler' user defined functions to be called when mousedown, mousemove and mouseup events occur.</p>

<p>The 'enableDrag' method creates a JavaScript Object type <b>DnD</b> which is assigned to the <i>Cobj</i>.<b>dragNdrop</b> property. DnD objects encapsulate the event handlers that are called when mousedown, mousemove and mouseup events occur within the outline of the Cobj as drawn on the canvas. When a mousedown event occurs the handler firstly enables listening for mousemove, mouseup and mouseout event, it then updates the various DnD property values and calls the user defined 'grabHandler' callback. Subsequent mousemove events will similarly update the DnD properties and call the user defined 'dragHandler'. The 'dropHandler' callback is called when either a mouseup event occurs or the cursor moves off the canvas generating a mouseout event. The callbacks are passed the current position of the cursor on the canvas in world coordinates. The callback functions are executed in the scope of the <i>Cobj</i>.dragNdrop object.</p>

<h3 id="DnD">DnD object properties</h3>

<p> The <i>obj</i>.dragNdrop is a DnD object which has as properties several variables often required when writing event handlers such as 'grabOfs', the cursor x,y offsets from the Cobj drawing origin when the mousedown event occurred. Since the callbacks are executed in the scope of the obj's <b>dragNdrop</b> object, 'this' will refer to the DnD object and its properties may be accessed as follows:</p>

<p><b>var</b> <i>localVar</i> = this.<i>property name</i>;</p>

<h4>Properties:</h4>

<p><b style="color:blue">grabCallback</b>:Function - The function to be called from the 'mousedown' event handler when the event occurs within the target object's outline path. The current cursor location is passed to the callback function as an object with properties 'x' and 'y' holding the respective coordinates of the cursor measured in world coordinates.</p>

<p><b style="color:blue">dragCallback</b>:Function - The function to be called from the 'mousemove' event handler following subsequent 'mousemove' events. The current cursor location is passed to the callback function as an object with properties 'x' and 'y' holding the respective coordinates of the cursor measured in world coordinates.</p>

<p><b style="color:blue">dropCallback</b>:Function - The function to be called from the 'mouseup' event handler following a subsequent canvas 'mouseup' event. The current cursor location is passed to the callback function as an object with properties 'x' and 'y' holding the respective coordinates of the cursor measured in world coordinates.</p>

<p><b style="color:blue">cgo</b>:Cango graphics object - The Cango graphics context that rendered the object onto the canvas. This makes the Cango methods such as 'this.cgo.clearCanvas()' readily accessible from the scope of the DnD object.</p>

<p><b style="color:blue">target</b>:Cobj object - this is the Cobj on which drag'n'drop has been enabled, it is provided for callback functions to easily access the target from the scope of the DnD object.</p>

<p><b style="color:blue">dwgOrg</b>:Object {x:, y:} - An object with properties x and y holding the 'as rendered' coordinates of the drawing origin of the target Cobj measured in world coordinates.</p>

<p><b style="color:blue">grabOfs</b>:Object {x:, y:} - An object with properties x and y holding the distances of the cursor from the target Cobj drawing origin at the time of the mousedown (grab) event, measured in world coordinates.</p>

<h4>Methods:</h4>

  <p><b style="color:blue">cancelDrag</b></p>
<h4>Syntax:</h4>
<p class='syntax'><b>this.cancelDrag</b>(mousePos);</p>
<h4>Description:</h4>
<p><b>cancelDrag</b> allows an application to disable mousemove events as if a mouseup event had occurred. Listening for mousemove, mouseup and mouseout events are disabled and the user defined 'dropHandler' function is called as if a genuine mouseup event had occurred. The 'mousePos' cursor position object is passed to 'dropHandler'.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'><b>mousePos</b>:Object - object with properties {x;, y:} holding a cursor position in world coordinates. This parameter will be passed to the drop handler, since no actual mouseup event has occurred this may be some manufactured mouse position. Since the cancelDrag method is usually called from within the user defined drag handler, the real mouse position will be available to be passed to the drop handler.</p>

<hr class="ugHr"/>
<h2>Cobj methods added</h2>

<h3 id="enableDrag" style="color:blue">enableDrag</h3>
<h4>Syntax:</h4>
<p class='syntax'><i>obj</i>.<b>enableDrag</b>(grabCallback, dragCallback, dropCallback);</p>
<h4>Description:</h4>
<p>This method creates a JavaScript Object type <b>DnD</b> which is assigned to the <i>obj</i>.<b>dragNdrop</b> property. DnD objects encapsulate the event handlers that run when mousedown, mousemove and mouseup events occur within the outline of the Cobj as drawn on the canvas. The event handlers call the user defined callback functions passed to 'enableDrag'. 'grabCallback' is called on a <b>mousedown</b> events, 'dragCallback' and 'dropCallback' functions are called on subsequent <b>mousemove</b> and <b>mouseup</b> or <b>mouseout</b> events. The current cursor location is passed to the callback functions as an object with properties 'x' and 'y' holding the respective coordinates of the cursor measured in world coordinates. The <i>obj</i> will have drag and drop capability enabled whenever it is rendered to the canvas.</p>
<p>Callback functions execute in the scope of the <i>obj</i>.<b>dragNdrop</b> object which provides the various properties for the convenience of writing callback function code.</p>
<p>As long as the <i>obj</i>.dragNdrop property is not 'null', mousedown events will be checked for this object. Drag-and-drop is de-activated for an object by calling the <i>obj</i>.disableDrag() method.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'><b>grabCallback</b>:Function or null - This function to be called when a 'mousedown' event occurs within the outline of 'obj'. An object containing the current cursor world coordinate position is the only parameter passed when the function is called. The cursor position object has 'x' and 'y' properties.</p>
<p style='margin-left:2em'><b>dragCallback</b>:Function or null - This function to be called when a 'mousemove' event occurs after the mouse down event has occurred with the outline of 'obj'. An object containing the current cursor world coordinate position is the only parameter passed when the function is called. The cursor position object has 'x' and 'y' properties.</p>
<p style='margin-left:2em'><b>dropCallback</b>:Function or null - This function to be called when a mouseup or mouseout event occurs after the mouse down event. An object containing the current cursor world coordinate position is the only parameter passed when the function is called. The cursor position object has 'x' and 'y' properties.</p>
<h4>Example</h4>
<p>As an example of the enableDrag method, here is a code snippet that simply moves text with the cursor: </p>
<div class="srcFmt">
<pre>
var g = new Cango(cvsID);
...
var x = 100, y = 30;

var dragTxt = function(mousePos)
{
  var wPos = {x:mousePos.x - this.grabOfs.x, y:mousePos.y - this.grabOfs.y};
  x = wPos.x;
  y = wPos.y;
  g.clearCanvas();
  g.render(txt, x, y);
};

var txt = new Cobj("Hullo", "TEXT", {fillColor:'blue', fontSize:25, fontWeight:600, lorg:5});
txt.enableDrag(null, dragTxt, null);
g.render(txt, x, y);
</pre>
</div>

<h3 id="disableDrag" style="color:blue">disableDrag</h3>
<h4>Syntax:</h4>
<p class='syntax'><i>obj</i>.<b>disableDrag</b>();</p>
<h4>Description:</h4>
<p>Sets the <i>obj</i>.dragNdrop property to 'null' and removes the reference to <i>obj</i> from the array of objects to be checked for a hit on mousedown events.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'><b>none</b></p>

<hr class="ugHr" />

<h3>Drag and Drop Example</h3>
<p>As an example of using the DnD properties in callback functions, here is code to draw a rotatable knob, showing how the callback functions 'knobGrab' and 'knobDrag' access the <i>DnD</i>.<b>dwgOrg</b> property: </p>

<canvas id="cgKnob" class="cvsEg" width="300" height="300"></canvas>

<div class="captionHolder" style="width: 400px">
  <p class="caption"><b>Figure 2.</b> Example of drag-n-drop, click on the knob and drag to rotate.</p>
</div>  <!-- captionHolder -->

<p>The code for the curve editor in Fig. 2 is show below.</p>

<div class="srcFmt" style="max-height:790px">
<pre>function simpleKnob(cvsID)
{
  "use strict";

  var ptrCmds, ptr, base, knob,
      grabOfsAng = 0,
      gc = new Cango(cvsID);

  function knobGrab(mousePos)
  {
    var csrX = mousePos.x - this.dwgOrg.x,
        csrY = mousePos.y - this.dwgOrg.y;
    grabOfsAng = Math.atan2(csrY, csrX);
  }

  function knobDrag(mousePos)
  {
    var csrX = mousePos.x - this.dwgOrg.x,
        csrY = mousePos.y - this.dwgOrg.y,
        angle = Math.atan2(csrY, csrX) - grabOfsAng;

    gc.clearCanvas();
    gc.render(knob, 0, 0, 1, 180*angle/Math.PI);
  }

  gc.clearCanvas();
  gc.setGridboxRHC();
  gc.setWorldCoords(-5, -5, 10);   // isotropic coords
  // make knob index marker line with lineWidth = 8
  ptrCmds = ['M', 1.2, 0, 'L', 2.5, 0];
  ptr = new Cobj(ptrCmds, "PATH", {strokeColor:'black', lineWidth:8});
  // make circular knob
  base = new Cobj(shapeDefs.circle(5), "SHAPE", {
    fillColor:'gold',
    border: true,
    strokeColor:'gray',
    lineWidth: 2,
    shadowOffsetX:0.1,
    shadowOffsetY:-0.2,
    shadowBlur:0.1,
    shadowColor:"#303030" });
  // enable Drag and Drop on the knob
  base.enableDrag(knobGrab, knobDrag, null);
  // save the components in knob array of Obj
  knob = [base, ptr];
  gc.render(knob);
}</pre>
</div>

<h3>Dedicated layer for drag-n-drop</h3>
<p>Since each mouse movement requires the canvas to be cleared and the object redrawn, drag and drop is greatly simplified if the object being dragged is drawn on a separate layer. Here is an example of a more sophisticated knob configured as a rotary pulse generator drawn on a layer separate to other objects.</p>

<p>The knob object is constructed by first defining a path representing one bump on the circumference. A little geometry was required to calculate the curves' start and end points. The Cgo2D data array for the segment is as follows:</p>
<div class="srcFmt">
<pre>
  var seg = ['M',1.3515,-0.6508, 'A',1,1,0,0,1,1.6824,-0.2624,
             'A',0.32,0.32,0,0,0,1.6824,0.2624, 'A',1,1,0,0,1,1.3515,0.6508];
</pre>
</div>
<p>Seven of these segments are then created by duplication using the <i>Cobj</i>.<b>dup</b> method, the segments are each rotated an extra 360/7 degrees and appended to the original to make the outline of the knob with 7 bumps on its circumference.</p>

<p>The knob objects can be scaled to any size when rendered.</p>
<p>A gradient fill and drop-shadow provide a nice 3D effect. A straight line index marker is then created. The knob object is formed by pushing the top and pointer components into a JavaScript array which can be re-rendered with an arbitrary rotation applied by the <b>render</b> method.</p>
<p>The knob top is made draggable. The drag handler makes the knob into a Rotary Pulse Generator, passing a pulse count (proportional to the angle turned) to the knob callback function. In this example the callback function accumulates the pulses in an up-down counter and the running total displayed in a readout.</p>

<p>The knob is drawn on a different layer to the counter readout so that the readout does not need to be redrawn for every mousemove event. The 'initKnob' function calls <i>Cango</i>.createLayer() and then generates a new Cango context to draw on the layer. The properties of this context are made to match the underlying canvas context by the call to <i>Cango</i>.dupCtx() method.</p>

  <canvas id="cgRPG" class="cvsEg" width="500" height="300"></canvas>

<div class="captionHolder" style="width: 550px">
  <p class="caption"><b>Figure 3.</b> A rotary pulse generator knob. Click on the knob and drag to rotate.</p>
</div>

<p>The source code for the RPG knob object is available in the file: <a href="KnobRpg-3v00.js">KnobRpg-3v00.js</a>.</p>




<h3>Zoom and Pan</h3>
<p>Support for zoom and pan of Cango drawings is provided by the global function <b>initZoomPan</b>. This function should be called after any canvas drawing layers have been created ensuring that the zoom and pan controls will be on the top layer of the stack and thus giving priority to then for any mouse click events.</p>

<p>A call to 'initZoomPan' </p>

<h3 id="initzoompan" style="color:blue">initZoomPan</h3>
<h4>Syntax:</h4>
<p class='syntax'><b>initZoomPan</b>(zpLayerId, gc, reDraw);</p>
<h4>Description:</h4>
<p>This function creates an overlay canvas and draws Zoom and Pan controls in the top right corner of a canvas element with ID 'zpLayerId'. Any or all the Cango contexts defined on any of the canvases in the stack can be zoomed and panned by clicking on these controls. The Cango contexts to be affected by zooming and panning are set by the 'gc' parameter. 'gc' may be a single Cango context or an array of contexts. Clicking the zoom controls will re-scaling the world coordinates of these contexts by 20% per click. Clicking the pan controls will add or subtract 50 pixels per click to the corresponding coordinate offset. When the scaling or position offsets have been applied, the Cango drawings on the canvas must be re-drawn to show the effect. The callback function to do this re-draw is also passed as the 'reDraw' argument.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'><b>zpLayerId</b>:String - This is the string ID of the canvas layer that will hold the zoom and pan control buttons. This is the ID returned from a call to <i>Cango</i>.createLayer() method, so a call to this method may be used in place of the string.</p>
<p style='margin-left:2em'><b>gc</b>:Cango context or Array of Cango contexts - This is the Cango graphics context that will have all its drawing zoomed or panned. If several Contexts are present on the background canvas or any canvas layer they may be passed as an array of Cango contexts, all will be zoomed or panned together as the control buttons are clicked.</p>
<p style='margin-left:2em'><b>reDraw</b>:Function - The user defined function 'redraw' will be called to redraw all the Cobjs on all the canvases in their new zoomed or panned size or position.</p>

<h3>Zoom and Pan Example</h3>

<canvas id="cgZP" class="cvsEg" width="500" height="350"></canvas>

<div class="captionHolder" style="width: 500px">
  <p class="caption"><b>Figure 4.</b> Example of zoom and pan controls, click on the buttons in the top right corner to zoom or pan the drawing. Clicking on the 'X' button returns the drawing to its original size and position.</p>
</div>  <!-- captionHolder -->

<p>The code for the zoom and pan example in Fig. 4 is shown below. Note that the lineWidth of the IMG is set in world coordinates using the 'lineWidthWC' property so the border scales with zooming, whereas the border width of the yellow shape is set in pixels using the 'lineWidth' property and so doesn't scale with zooming.</p>

<div class="srcFmt" style="max-height:850px">
<pre>function zoomPanTest(cvsID)
{
  'use strict';
  var g,
      gL1,
      xmin = -300,
      ymin = -200,
      xspan = 750,
      Arc3 = "M0,50 h-150 a150,150 0 1,0 150,-150 z M-25,25 v-150 a150,150 0 0,0 -150,150 z",
      ro, jane, txt, arcsObj;

  g = new Cango(cvsID);
  g.setGridboxRHC();
  g.setWorldCoords(xmin, ymin, xspan);

  gL1 = new Cango(g.createLayer());
  gL1.dupCtx(g);

  jane = new Cobj("Images/JaneAvril2.jpg", "IMG", {
    imgHeight: 140,
    border:true,
    lineWidthWC:6,
    strokeColor:'sienna',
    shadowOffsetX:8,
    shadowOffsetY:-8,
    shadowBlur:4,
    shadowColor:'grey' });
  g.render(jane, 100, 200);

  txt = new Cobj("Caption", "TEXT", {fillColor:"red", fontSize:12});
  g.render(txt, 100, 40);

  arcsObj = new Cobj(svgToCgoRHC(Arc3), "SHAPE", {
    border:true,
    strokeColor:"red",
    lineWidth:2,       // pixels
    fillColor:"yellow" });
  gL1.render(arcsObj, 0,0, 0.5);

  function drawBits()
  {
    g.clearCanvas();
    g.render(jane, 100, 200);
    g.render(txt, 100, 40);
    gL1.clearCanvas();
    gL1.render(arcsObj, 0,0, 0.5);
  }

  initZoomPan(g.createLayer(), [g, gL1], drawBits);
}
</pre>
</div>

        </div>  <!-- text_01 -->
      </div>   <!--  content -->
    </div>  <!-- page  -->

  </div>   <!-- outer -->

</body>
</html>