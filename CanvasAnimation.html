<!DOCTYPE HTML>
<html>
<head>
  <title>Cango2D Canvas Graphics</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="keywords" content="JavaScript graphics, canvas graphics, canvas animation, Cango2D, canvas graphics library, canvas animation library">

  <link rel="stylesheet" href="2ColStickyScroll-14.css" media="all" type="text/css" />
  <style type="text/css" media="screen">
    @import "contentStyle-18.css";
    @import "console-43.css";

    .cvsEg {
      position: relative;   /* positioned to parent bottom menus */
      display: block;       /* must have for position canvas elements */
      margin: 20px auto;
      padding: 0;
      background-color: lightyellow;
      border: 2px solid black;
    }
    .cvsWrapper {
      position:relative;
      display: table;
      padding: 0;
      margin: 0 auto;
    }
  </style>

  <script type="text/javascript">
    var sidebar = null,
        sidebar_top = 100;

    if (typeof addLoadEvent === "undefined")
    {
      var addLoadEvent = function(func)
      {
      	var oldonload = window.onload;
      	if (typeof window.onload != 'function')
        {
          window.onload = func;
        }
      	else
        {
        	window.onload = function(){oldonload();	func();}
        }
      }
    }

    if (typeof addEvent === "undefined")
    {
      var addEvent = function(element, eventType, handler)
      {
        if (element.attachEvent)
        {
          return element.attachEvent('on'+eventType, handler);
        }
        return element.addEventListener(eventType, handler, false);
      };
    }

    function cancelBubble(e)
    {
      var evt = e ? e:window.event;
      if (evt.stopPropagation) evt.stopPropagation();
      if (evt.cancelBubble!=null) evt.cancelBubble = true;
    }

    /* -------------------------------------------------------------------------
     * buildMenu(dataArray)
     *
     * dataArray should be in JSON format as follows
     * [ {"url":"url of file", "title":"String to display in index"},
     *   {"url":"url of file", "title":"String to display in index",
     *    "chapters": [
     *       {"url":"url of file", "title":"String to display in index"},
     *       {"url":"url of file", "title":"String to display in index"},
     *       ...
     *       {"url":"url of file", "title":"String to display in index"}
     *     ]
     *   },
     *   {"url":"url of file", "title":"String to display in index"},
     *   ...
     * ]
     * Then build HTML anchors from the array.
     *--------------------------------------------------------------------------*/
    function buildMenu(dataArray)
    {
      var menuNode = document.getElementById("sideNav"),
          htmlStr = "",
          currPage,
          i;

      function subStringReplaceAt(str, index, newSubStr, oldSubStrLength)
      {
        return str.slice(0, index) + newSubStr + str.slice(index+oldSubStrLength);
      }

      function parseAry(obj)
      {
        var currPage = document.URL.replace(/^.*[\\\/]/, ''),   // split off the page name (cross platform)
            i;
        for (i=0; i<obj.length; i++)
        {
          if (obj[i].chapters)
          {
            htmlStr += "<ul>";
            htmlStr += "<li class='sectClosed'><input type='button' onclick='toggleSection(this)' value='"+obj[i].title+"'><ul class='options'>";
            parseAry(obj[i].chapters);
            htmlStr += "</ul></li>";
          }
          else
          {
            htmlStr += "<li><a href='"+obj[i].url+"' target='_top'>"+obj[i].title+"</a></li>";
            // check if this index entry is the current page, if open this section to show link
            if (currPage == obj[i].url)
            {
              htmlStr = subStringReplaceAt(htmlStr, htmlStr.lastIndexOf("sectClosed"), "sectOpen", 10);
            }
          }
        }
      }

      parseAry(dataArray);
      menuNode.innerHTML += htmlStr;
    }

    function toggleSection(btn)
    {
      if (btn && btn.parentNode.className === "sectClosed")
      {
        btn.parentNode.className = "sectOpen";
      }
      else if (btn && btn.parentNode.className === "sectOpen")
      {
        btn.parentNode.className = "sectClosed";
      }
      return false;   // is used with anchor will prevent going to href
    }

    function enableStickyNav()
    {
      var stickyElements = document.getElementsByClassName('sticky');

      for (var i = stickyElements.length - 1; i >= 0; i--) {
          Stickyfill.add(stickyElements[i]);
      }
    }
  </script>

<!-- 'indexNested.js' defines the global 'var indexData' holding menu entries  -->
  <script type="text/javascript" src="indexNested.js"></script>
  <script src="stickyfill.js"></script>

  <script type="text/javascript" src="Cango2D-7v01-min.js"></script>

  <script type="text/javascript">

    var armCtx;

    function robotArmDemo(cvsID)
    {
      var standData, stand,
          axle0, axle1, axle2, axle3,
          armGrp,
          segData, seg4Data,
          seg1, seg2, seg3, seg4,
          seg1Grp, seg2Grp, seg3Grp,
          animData, armTwnr;

      armCtx = new Cango2D(cvsID);
      armCtx.clearCanvas("lightyellow");     // disables any previous dragNdrop handlers on this canvas
      armCtx.setWorldCoords(-50, -50, 300);

      standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z'];
      stand = new Obj2D(standData, "SHAPE", {
        fillColor:'darkgray',
        border: true,
        strokeColor: "#222222" });
      axle0 = new Obj2D(shapeDefs.circle(10), "SHAPE", {
        fillColor:'gray',
        border: true,
        strokeColor: "#222222" });
      armGrp = armCtx.createGroup2D(stand, axle0);

      segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z'];

      seg1 = new Obj2D(segData, "SHAPE", {
        fillColor:'darkGray',
        border: true,
        strokeColor: "#222222",
        zIndex: -1 });
      axle1 = new Obj2D(shapeDefs.circle(8), "SHAPE", {
        fillColor:'gray',
        border: true,
        strokeColor: "#222222",
        zIndex: 1 });
      axle1.translate(50, 0);
      seg1Grp = armCtx.createGroup2D(seg1, axle1);

      armGrp.addObj(seg1Grp);

      seg2 = new Obj2D(segData, "SHAPE", {
        fillColor:'darkGray',
        border: true,
        strokeColor: "#222222",
        zIndex: -1 });
      axle2 = new Obj2D(shapeDefs.circle(8), "SHAPE", {
        fillColor:'gray',
        border: true,
        strokeColor: "#222222",
        zIndex: 1 });
      axle2.translate(50, 0);
      seg2Grp = armCtx.createGroup2D(seg2, axle2);

      seg1Grp.addObj(seg2Grp);

      seg3 = new Obj2D(segData, "SHAPE", {
        fillColor:'darkGray',
        border: true,
        strokeColor: "#222222",
        zIndex: -1 });
      axle3 = new Obj2D(shapeDefs.circle(6), "SHAPE", {
        fillColor:'gray',
        border: true,
        strokeColor: "#222222",
        zIndex: 1 });
      axle3.translate(50, 0);
      seg3Grp = armCtx.createGroup2D(seg3, axle3);

      seg2Grp.addObj(seg3Grp);

      seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z'];
      seg4 = new Obj2D(seg4Data, "SHAPE", {
        fillColor:'darkGray',
        border: true,
        strokeColor: "#222222",
        zIndex: -1 });

      seg3Grp.addObj(seg4);

      // now set up animation
      animData = {s1: [0, 80, 45, 0],
                  s2: [0, -60, -60, 0],
                  s3: [0, -90, 0, 90, 0],
                  s4: [0, 30, -90, 0]};

      armTwnr = new Tweener(0, 3500, 'loop');

      function initArm(opts)
      {
        seg2Grp.transform.translate(50,0);
        seg3Grp.transform.translate(50,0);
        seg4.transform.translate(50,0);
      }

      function armPathFn(time, opts)
      {
        var seg1Rot = armTwnr.getVal(time, opts.s1),
            seg2Rot = armTwnr.getVal(time, opts.s2),
            seg3Rot = armTwnr.getVal(time, opts.s3),
            seg4Rot = armTwnr.getVal(time, opts.s4);

        seg1Grp.transform.rotate(seg1Rot);
        seg2Grp.transform.rotate(seg2Rot);
        seg2Grp.transform.translate(50,0);
        seg3Grp.transform.rotate(seg3Rot);
        seg3Grp.transform.translate(50,0);
        seg4.transform.rotate(seg4Rot);
        seg4.transform.translate(50,0);
      }

      armCtx.animate(armGrp, initArm, armPathFn, animData);
      armCtx.playAnimation();
    }

//================================================================================

    function drawShapes(cvsID)
    {
      var x1 = 80, y1 = 20,
          cx1 = 90, cy1 = 120,
          x2 = 120, y2 = 100,
          cx2 = 150, cy2 = 20,
          cx3 = 150, cy3 = 120,
          x3 = 180, y3 = 60,
          jane,
          data, quad,
          L1, L2, L3,
          dot1, dot2, dot3,
          cub, grad, circ, cross, sq1, sq2,
          blueLine, tri, hole,
          hullo,
          g = new Cango2D(cvsID);

      g.clearCanvas("wheat");
      g.setWorldCoords(0, 0, 200);

      jane = new Obj2D("Images/JaneAvril2.jpg", "IMG", {
        imgWidth:25,
        lorg:1,
        border:true,
        strokeColor:'orange',
        lineWidth:5,
        shadowOffsetX: 3,
        shadowOffsetY: -3,
        shadowBlur: 3,
        shadowColor: 'dimgray' }),
      jane.transform.translate(170, 130);
      g.render(jane);
      hullo = new Obj2D("24px TEXT", "TEXT", {
        fillColor:'green',
        fontSize:24,
        fontWeight: 700,
        lorg:1 });
      hullo.translate(150, 40);
      g.render(hullo);
      // draw a quadratic bezier from x1,y2 to x2,y2
      data = ['M', x1, y1, 'Q', cx1, cy1, x2, y2];
      quad = new Obj2D(data, "PATH", {strokeColor:'blue'});
      g.render(quad);
      // show the control point and line
      data = ['M', x1, y1, 'L', cx1, cy1, x2, y2];
      L1 = new Obj2D(data, "PATH", {strokeColor:"rgba(0, 0, 0, 0.2)", dashed:[4]});
      g.render(L1);

      dot1 = new Obj2D(shapeDefs.circle(4), "SHAPE", {fillColor:'red'});
      dot2 = dot1.dup();
      dot3 = dot1.dup();
      dot1.translate(cx1, cy1);
      g.render(dot1);

      // now draw a cubic bezier (from current point x2,y2 to x3,y3)
      data = ['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3];
      cub = new Obj2D(data, "PATH", {strokeColor:'green'});
      g.render(cub);
       // show the 2 control points
      data = ['M', x2, y2, 'L', cx2, cy2];
      L2 = new Obj2D(data, "PATH", {strokeColor:"rgba(0, 0, 0, 0.2)", dashed:[4]});
      g.render(L2);
      dot2.translate(cx2, cy2);
      g.render(dot2);

      data = ['M', x3, y3, 'L', cx3, cy3];
      L3 = new Obj2D(data, "PATH", {strokeColor:"rgba(0, 0, 0, 0.2)", dashed:[4]});
      g.render(L3);
      dot3.translate(cx3, cy3);
      g.render(dot3);

      grad = new RadialGradient(-12, 12, 4, -12, 12, 37);
      grad.addColorStop(0, '#ff8888');
      grad.addColorStop(0.3, 'red');
      grad.addColorStop(0.8, '#aa3333');
      grad.addColorStop(1, '#442222');

      circ = new Obj2D(shapeDefs.circle(50), "SHAPE", {fillColor:grad});
      circ.transform.translate(35, 40);   // use soft transform, gradients track dwgOrg which doesn't move with hard transforms
      g.render(circ);

      cross = new Obj2D(shapeDefs.cross(20), "PATH", {strokeColor:'blue'});
      cross.translate(35, 40);
      g.render(cross);

      var sq2 = new Obj2D(shapeDefs.rectangle(40, 30, 7), "SHAPE", {
        fillColor:"rgba(64, 64, 200, 0.5)",
        border: true,
        strokeColor: "yellow",
        lineWidth: 2 });
      sq2.translate(57, 20);
      g.render(sq2);

      sq1 = new Obj2D(shapeDefs.square(18), "PATH", {
        strokeColor:"#00ff00",
        lineWidthWC:2,
        shadowOffsetX: 2,
        shadowOffsetY: -2,
        shadowBlur: 3,
        shadowColor: '#303030'});
      sq1.transform.translate(15, 110);
      g.render(sq1);
      // now scale this to see line width scale too
      sq1.transform.reset();
      sq1.transform.scale(2);
      sq1.transform.translate(30, 110);
      g.render(sq1);

      blueLine = new Obj2D([30, 80, 150, 10], "PATH", {
        strokeColor:'blue',
        lineWidth:18,
        lineCap:'round' });
      g.render(blueLine);

      tri = new Obj2D(shapeDefs.triangle(50), "SHAPE", {fillColor:'orange'});
      hole = new Obj2D(shapeDefs.circle(20), "PATH");
      hole.revWinding();
      tri.appendPath(hole);
      tri.translate(120, 30);
      g.render(tri);
    }

//===================================================================================

    function drawPaths(cvsID)
    {
      var Triangle = "M 100 100 L 300 100 L 200 300 z",
          CubicBezier = "M100,200 C100,100 250,100 250,200 S400,300 400,200",
          QuadBezier2 = "M200,300 Q400,50 600,300 T1000,300",
          Arc1 = "M300,200 h-150 a150,150 0 1,0 150,-150 z",
          Arc2 = "M275,175 v-150 a150,150 0 0,0 -150,150 z",
          Arc3 = "M600,350 l 50,-25a25,25 -30 0,1 50,-25 l 50,-25\
                  a25,50 -30 0,1 50,-25 l 50,-25a25,75 -30 0,1 50,-25 l 50,-25\
                  a25,100 -30 0,1 50,-25 l 50,-25",
          tri, cBez, qBez,
          a1, a2, a3,
          g = new Cango2D(cvsID);

      g.clearCanvas("cornsilk");               // clear all previous drawing and text
      g.setWorldCoords(0, 0, 1000);

      tri = new Obj2D(svgToCgo2D(Triangle), "SHAPE", {fillColor:'red'});
      tri.translate(100, 950);
      g.render(tri);
      cBez = new Obj2D(svgToCgo2D(CubicBezier), "PATH", {strokeColor:'red'});
      cBez.translate(400, 1000);
      g.render(cBez);
      qBez = new Obj2D(svgToCgo2D(QuadBezier2), "PATH", {strokeColor:'red'});
      qBez.translate(-100, 750);
      g.render(qBez);
      a1 = new Obj2D(svgToCgo2D(Arc1), "SHAPE", {
        fillColor:'red',
        border: true,
        strokeColor: "blue" });
      a1.translate(50, 400);
      g.render(a1);
      a2 = new Obj2D(svgToCgo2D(Arc2), "SHAPE", {
        fillColor:"yellow",
        border: true,
        strokeColor: "blue" });
      a2.translate(50, 400);
      g.render(a2);
      a3 = new Obj2D(svgToCgo2D(Arc3), "PATH", {strokeColor:'red'});
      a3.translate(-100, 400);
      g.render(a3);
    }

//================================================================================

    function editCurve(cvsID)
    {
      var x1 = 40, y1 = 20,
          cx1 = 90, cy1 = 120,
          x2 = 120, y2 = 100,
          cx2 = 130, cy2 = 20,
          cx3 = 150, cy3 = 120,
          x3 = 180, y3 = 60,
          c1, c2, c3,
          g = new Cango2D(cvsID);

      function dragC1(mousePos)    // called in scope of dragNdrop obj
      {
        cx1 = mousePos.x;
        cy1 = mousePos.y;
        drawCurve();
      }

      function dragC2(mousePos)
      {
        cx2 = mousePos.x;
        cy2 = mousePos.y;
        drawCurve();
      }

      function dragC3(mousePos)
      {
        cx3 = mousePos.x;
        cy3 = mousePos.y;
        drawCurve();
      }

      function drawCurve()
      {
        var qbez, cbez,
            grp,
            L1, L2, L3;
        // curve change shape so it must be re-constructed each time
        // draw a quadratic bezier from x1,y2 to x2,y2
        qbez = new Obj2D(['M', x1, y1, 'Q', cx1, cy1, x2, y2], "PATH", {
          strokeColor:'blue'});
        cbez = new Obj2D(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], "PATH", {
          strokeColor:'green'});
        // show lines to control point
        L1 = new Obj2D(['M', x1, y1, 'L', cx1, cy1, x2, y2], "PATH", {
          strokeColor:"rgba(0, 0, 0, 0.2)",
          dashed:[4]});   // semi-transparent gray
        L2 = new Obj2D(['M', x2, y2, 'L', cx2, cy2], "PATH", {
          strokeColor:"rgba(0, 0, 0, 0.2)",
          dashed:[4]});
        L3 = new Obj2D(['M', x3, y3, 'L', cx3, cy3], "PATH", {
          strokeColor:"rgba(0, 0, 0, 0.2)",
          dashed:[4]});
        // draw draggable control points
        c1.transform.translate(cx1, cy1);
        c2.transform.translate(cx2, cy2);
        c3.transform.translate(cx3, cy3);
        grp = g.createGroup2D(qbez, cbez, L1, L2, L3, c1, c2, c3);
        g.clearCanvas();
        g.render(grp);
      }

      g.clearCanvas("lightyellow");
      g.setWorldCoords(0, 0, 200);

      // draggable control points
      c1 = new Obj2D(shapeDefs.circle(4), "SHAPE", {fillColor:'red'});
      c1.enableDrag(null, dragC1, null);

      c2 = c1.dup();
      c2.enableDrag(null, dragC2, null);

      c3 = c1.dup();
      c3.enableDrag(null, dragC3, null);

      drawCurve();
    }

//=================================================================================

    function dragArm(cvsID)
    {
      var g = new Cango2D(cvsID);
      g.clearCanvas("lightyellow");     // disables any previous dragNdrop handlers on this canvas
      g.setWorldCoords(-50, -50, 300);

      var standData, stand,
          axle0, axle1, axle2, axle3,
          armGrp,
          segData, seg4Data,
          seg1, seg2, seg3, seg4,
          seg1Grp, seg2Grp, seg3Grp;

      function segGrab(mousePos)
      {
        // this=drag2D, this.target=Obj2D or Group2D being dragged
        var segGrp = this.target,
            csrX = mousePos.x - this.dwgOrg.x,
            csrY = mousePos.y - this.dwgOrg.y;

        segGrp.grabOfsAng = Math.atan2(csrY, csrX) - segGrp.angle;    // all angles in radians
      }

      function seg1Drag(mousePos)
      {
        var segGrp = this.target,
            csrX = mousePos.x - this.dwgOrg.x,
            csrY = mousePos.y - this.dwgOrg.y;

        segGrp.angle = Math.atan2(csrY, csrX) - segGrp.grabOfsAng;   // save angle as a property
        if (segGrp.angle > Math.PI/2)
        {
          segGrp.angle = Math.PI/2;
        }
        else if (segGrp.angle < 0)
        {
          segGrp.angle = 0;
        }

        seg1Grp.transform.rotate(seg1Grp.angle*180/Math.PI);
        seg2Grp.transform.rotate(seg2Grp.angle*180/Math.PI);
        seg2Grp.transform.translate(50,0);
        seg3Grp.transform.rotate(seg3Grp.angle*180/Math.PI);
        seg3Grp.transform.translate(50,0);
        seg4.transform.rotate(seg4.angle*180/Math.PI);
        seg4.transform.translate(50,0);

        g.render(armGrp, true);
      }

      function segDrag(mousePos)
      {
        var segGrp = this.target,
            csrX = mousePos.x - this.dwgOrg.x,
            csrY = mousePos.y - this.dwgOrg.y;

        segGrp.angle = Math.atan2(csrY, csrX) - segGrp.grabOfsAng;   // save angle as a property
        if (segGrp.angle > Math.PI/2)
        {
          segGrp.angle = Math.PI/2;
        }
        else if (segGrp.angle < -Math.PI/2)
        {
          segGrp.angle = -Math.PI/2;
        }

        seg1Grp.transform.rotate(seg1Grp.angle*180/Math.PI);
        seg2Grp.transform.rotate(seg2Grp.angle*180/Math.PI);
        seg2Grp.transform.translate(50,0);
        seg3Grp.transform.rotate(seg3Grp.angle*180/Math.PI);
        seg3Grp.transform.translate(50,0);
        seg4.transform.rotate(seg4.angle*180/Math.PI);
        seg4.transform.translate(50,0);

        g.render(armGrp, true);
      }

      standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z'];
      stand = new Obj2D(standData, "SHAPE", {
        fillColor:'darkgray',
        border: true,
        strokeColor: "#222222" });
      axle0 = new Obj2D(shapeDefs.circle(10), "SHAPE", {
        fillColor:'gray',
        border: true,
        strokeColor: "#222222" });
      armGrp = g.createGroup2D(stand, axle0);

      segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z'];

      seg1 = new Obj2D(segData, "SHAPE", {
        fillColor:'darkGray',
        border: true,
        strokeColor: "#222222",
        zIndex: -1 });
      axle1 = new Obj2D(shapeDefs.circle(8), "SHAPE", {
        fillColor:'gray',
        border: true,
        strokeColor: "#222222",
        zIndex: 1 });
      axle1.translate(50, 0);
      seg1Grp = g.createGroup2D(seg1, axle1);


      armGrp.addObj(seg1Grp);

      seg2 = new Obj2D(segData, "SHAPE", {
        fillColor:'darkGray',
        border: true,
        strokeColor: "#222222",
        zIndex: -1 });
      axle2 = new Obj2D(shapeDefs.circle(8), "SHAPE", {
        fillColor:'gray',
        border: true,
        strokeColor: "#222222",
        zIndex: 1 });
      axle2.translate(50, 0);
      seg2Grp = g.createGroup2D(seg2, axle2);

      seg1Grp.addObj(seg2Grp);

      seg3 = new Obj2D(segData, "SHAPE", {
        fillColor:'darkGray',
        border: true,
        strokeColor: "#222222",
        zIndex: -1 });
      axle3 = new Obj2D(shapeDefs.circle(6), "SHAPE", {
        fillColor:'gray',
        border: true,
        strokeColor: "#222222",
        zIndex: 1 });
      axle3.translate(50, 0);
      seg3Grp = g.createGroup2D(seg3, axle3);

      seg2Grp.addObj(seg3Grp);

      seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z'];
      seg4 = new Obj2D(seg4Data, "SHAPE", {
        fillColor:'darkGray',
        border: true,
        strokeColor: "#222222",
        zIndex: -1 });

      seg3Grp.addObj(seg4);

      //------ setup initial posiiton ------------
      seg1Grp.angle = 1;       // 1 radian
      seg2Grp.angle = -1;      // radians
      seg3Grp.angle = -0.5;
      seg4.angle = 0.8;
      // apply these transforms
      seg1Grp.transform.rotate(seg1Grp.angle*180/Math.PI);
      seg2Grp.transform.rotate(seg2Grp.angle*180/Math.PI);
      seg2Grp.transform.translate(50,0);
      seg3Grp.transform.rotate(seg3Grp.angle*180/Math.PI);
      seg3Grp.transform.translate(50,0);
      seg4.transform.rotate(seg4.angle*180/Math.PI);
      seg4.transform.translate(50,0);

      // set up the drag handlers
      // give each segment its own 'grabOfsAng' property to save the state
      // seg4 is an Obj2D no group needed (its got no children)
      seg4.grabOfsAng = 0;
      seg4.enableDrag(segGrab, segDrag, null);
      // order of enabling drag is import to let children drag independently
      seg3Grp.grabOfsAng = 0;
      seg3Grp.enableDrag(segGrab, segDrag, null);
      seg2Grp.grabOfsAng = 0;
      seg2Grp.enableDrag(segGrab, segDrag, null);
      seg1Grp.grabOfsAng = 0;
      seg1Grp.enableDrag(segGrab, seg1Drag, null); // seg1Grp drag doesn't have the x=50 translation

      g.render(armGrp, true);
    }

//================================================================================

    var ballGC;           // ball graphics context

    function sphereShading(dia, r, g, b)
    {
      var rVal = r || 0,
          gVal = g || 0,
          bVal = b || 0,
          d = dia || 100,
          hx = 0.3,   // 0.05 < hx < 0.45 (fraction of sphere diameter that shadow is offset from center)
          bx = 0.5 - hx,
          sx = 1 - 0.6 + hx,
          shadowGrad = new RadialGradient(-0.7*sx*d, 0.7*sx*d, 0.9*d, -0.7*sx*d, 0.7*sx*d, 1.1*d), // rotate by 135deg,
          brightGrad = new RadialGradient(-0.7*bx*d, 0.7*bx*d, d/15, -0.7*bx*d, 0.7*bx*d, 3*d); // rotate by 135deg
          ballGrad =  new RadialGradient(0, 0, 0.4*d, 0, 0, 0.5*d);

      shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.03)");
      shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.3)");
      shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0.5)");

      brightGrad.addColorStop(0, "rgba(255,255,255,0.77)");
      brightGrad.addColorStop(0.1, "rgba(255,255,255,0.2)");
      brightGrad.addColorStop(0.7, "rgba(255,255,255,0)");

      ballGrad.addColorStop(0, "rgb("+rVal+","+gVal+","+bVal+")");
      ballGrad.addColorStop(0.7, "rgb("+Math.round(0.9*rVal)+","+Math.round(0.9*gVal)+","+Math.round(0.9*bVal)+")");
      ballGrad.addColorStop(1, "rgb("+Math.round(0.8*rVal)+","+Math.round(0.8*gVal)+","+Math.round(0.8*bVal)+")");

      return {base:ballGrad, shadow:shadowGrad, hilite:brightGrad};
    }

    function beachBallDemo(cvsID)
    {
      var circle = "M 534.29,274.5 A 165.7,165.7 0 1 1 202.9,274.5 165.7,165.7 0 1 1 534.3,274.5 z",
          stripes = "M 279.1,134.7 C 260,193.8 318.1,303.8 349.5,343.8 338.3,349.3 330.3,357.9 331.1,372.0 282.5,369.2 232.8,353.1 207.3,313.1 220.9,367.5 258.7,410.6 312,430.4 331.1,419.5 336.5,412.9 349.8,395.6 361.7,401.3 377.6,400.1 388.6,394.2 404.8,411.9 414.6,420.0 433.6,427 482.7,405.2 518.4,364.5 530.7,309.3 508.9,343.1 462.8,363.7 404.7,369.4 404.1,356.7 396.1,348.5 384.8,343.2 426.2,276 460.9,182 451.8,130.9 393.8,98.6 330.4,103 279.1,134.7 z",
          xRef = 368.57,  // this is the reference point expressed in Inkscape coords
          yRef = 274.5,
          dia = 2*165.7,
          ballData, ball,
          panelsData, panels,
          shade, shading, shadows,
          beachball,
          twnr,
          ballConfig = {x:[1100, 150, 1100],
                        y:[300, 200, 300],
                        scl:[0.6, 1, 0.6],
                        rot:[0, 360, 0],
                        delay:0,
                        duration:3500,
                        loop:'loop' };

			twnr = new Tweener(ballConfig.delay, ballConfig.duration, ballConfig.loop);

			function initBall(opts)
      {
				this.obj.transform.translate(1100, 300);
				this.obj.transform.scale(0.6);
			}

			function ballPathFn(time, opts)
			{
				var sclVal = twnr.getVal(time, opts.scl),
            xVal = twnr.getVal(time, opts.x),
            yVal = twnr.getVal(time, opts.y),
            rotVal = twnr.getVal(time, opts.rot);

				this.obj.transform.scale(sclVal);
				this.obj.transform.rotate(rotVal);
				this.obj.transform.translate(xVal, yVal);
			}

			function shadePathFn(time, opts)
			{
				var sclVal = twnr.getVal(time, opts.scl),
            xVal = twnr.getVal(time, opts.x),
            yVal = twnr.getVal(time, opts.y);

				this.obj.transform.scale(sclVal);
				this.obj.transform.translate(xVal, yVal);
			}

      ballGC = new Cango2D(cvsID);
      ballGC.setWorldCoords(0, 0, 1200); // square pixels

      ballData = svgToCgo2D(circle, -xRef, -yRef);
      ball = new Obj2D(ballData, "SHAPE", {fillColor:"ghostwhite"});

      panelsData = svgToCgo2D(stripes, -xRef, -yRef);
      panels = new Obj2D(panelsData, "SHAPE", {fillColor:"red"});

      shadows = sphereShading(dia),
      shade = new Obj2D(shapeDefs.circle(dia), "SHAPE", {fillColor:shadows.shadow});
      ballHilite = new Obj2D(shapeDefs.circle(dia), "SHAPE", {fillColor:shadows.hilite});

			beachball = ballGC.createGroup2D(ball, panels);
			shading = ballGC.createGroup2D(shade, ballHilite);

      ballGC.animate(beachball, initBall, ballPathFn, ballConfig);
      ballGC.animate(shading, initBall, shadePathFn, ballConfig);

 //      ballGC.playAnimation();
    }

//=================================================================================

    var bounceGC;           // Cango2D graphics context

    function initBall(opts)
    {
      // create any properties you want in nextState, currState will be a clone
      // don't write to currState its just there for reference to what is on the screen
      this.nextState.x = 120;
      this.nextState.y = 250;
      this.nextState.vx = 0;
      this.nextState.vy = 0;

      this.obj.transform.translate(this.nextState.x, this.nextState.y);
    }

    function bouncingPath(time, opts)    // time passed is the time since start of animation
    {
      // 'this' refers to the Animation object (this.obj, this.gc, this.nextState, this.pathFn etc)
      // currState is avaliable for reference to what is on the screen (don't write to it)
      // after obj is drawn in nextState, nextState and currState are swapped
      var reflect = -1,     // bounce off wall else disappear
          coeff = 0.82,     // percentage bounce height (superball)
          friction = 0.985, // rolling friction loss/msec
          speed = 1.5,      // units are like worldCoords x axis units/mm
          gravity = -0.0098 * speed, // gravity =9.8m/s/s =0.0098mm/ms/ms =0.0098*speed units/ms/ms
          xVel = 0,
          yVel = 0,
          x, y,
          vel, startAngle, timeInt, s, u;

      if (time == 0)   // generate random launch angle for each reset
      {
        // restart at a random angle
        // velocity in 2m/s = 2 mm/ms = 2mm/ms * units/mm = 2*speed
        vel = 2*speed;    // x units/ms
        startAngle = 30+120*Math.random();
        this.nextState.x = 120;           // put ball back at the start point
        this.nextState.y = 250;
        this.nextState.vx = vel * Math.cos(startAngle * Math.PI / 180);
        this.nextState.vy = vel * Math.sin(startAngle * Math.PI / 180);

        this.obj.transform.translate(this.nextState.x, this.nextState.y);
        return;     // this is the state to get drawn at start
      }
      // calculate the new position and velocity
      timeInt = time - this.currState.time;   // time since last draw
      // v = u + at
      yVel = this.currState.vy + gravity * timeInt;    // accelerating due to gravity
      xVel = this.currState.vx;                    // constant
      x = this.currState.x + xVel*timeInt;
      y = this.currState.y + yVel*timeInt + 0.5*gravity * timeInt * timeInt;
       // now check for hitting the walls
      if (x > opts.rightWall - opts.radius)
      {
        x = opts.rightWall - opts.radius;
        xVel *= reflect*coeff;    // lossy reflection next step
      }
      if (x < opts.leftWall + opts.radius)
      {
        x = opts.leftWall + opts.radius;
        xVel *= reflect*coeff;    // lossy reflection next step
      }
      if (y > opts.topWall - opts.radius)
      {
        y = opts.topWall - opts.radius;
        yVel *= reflect*coeff;    // lossy reflection next step
      }
      if (y < opts.bottomWall + opts.radius)  // this is always true after yVel become small
      {
        y = opts.bottomWall + opts.radius;
        // calc velocity at the floor   (v^2 = u^2 + 2*g*s)
        s = this.currState.y - (opts.bottomWall + opts.radius);     // pre bounce
        u = this.currState.vy;
        yVel = -Math.sqrt(u*u - 2*gravity*s);
        yVel *= reflect*coeff;  // lossy reflection next step
        // after bouncing phase this is rolling friction
        xVel *= friction;
      }
      this.nextState.x = x;
      this.nextState.y = y;
      this.nextState.vx = xVel;
      this.nextState.vy = yVel;

      this.obj.transform.translate(this.nextState.x, this.nextState.y); // move to next position
    }

    function bouncingBallDemo(cvsID)
    {
      var shadows,
          ball, shade, ballHilite,
          ballGrp,
          dia = 45;

      shadows = sphereShading(dia, 255, 0, 0);

      ball = new Obj2D(shapeDefs.circle(dia), "SHAPE", {fillColor:shadows.base} );
      shade = new Obj2D(shapeDefs.circle(dia), "SHAPE", {fillColor:shadows.shadow});
      ballHilite = new Obj2D(shapeDefs.circle(dia), "SHAPE", {fillColor:shadows.hilite});

      bounceGC = new Cango2D(cvsID);
      bounceGC.setWorldCoords();      // use raw pixels

      ballGrp = bounceGC.createGroup2D(ball, shade, ballHilite);
      bounceGC.animate(ballGrp, initBall, bouncingPath, { radius:dia/2,
                                                          leftWall:0,
                                                          rightWall:bounceGC.rawWidth,
                                                          topWall:bounceGC.rawHeight,
                                                          bottomWall:0 });
    }

//=================================================================================

    function sayHullo(cvsID)
    {
      var g = new Cango2D(cvsID);
      g.setViewport();     // full canvas
      g.setWorldCoords(0, 0, 10);

      g.drawText("Hullo World", 5, 4, {fillColor:'red', fontSize:36, lorg:5});
    }

    var bball;


    var consoleBtns1 =
    {
      f1:function(){armCtx.playAnimation()},
      f2:function(){armCtx.pauseAnimation()},
      f3:function(){armCtx.stepAnimation()},
      f4:function(){armCtx.stopAnimation()}
    };

    var consoleBtns2 =
    {
      f1:function(){ballGC.playAnimation()},
      f2:function(){ballGC.pauseAnimation()},
      f3:function(){ballGC.stepAnimation()},
      f4:function(){ballGC.stopAnimation()}
    };

    var consoleBtns3 =
    {
      f1:function(){bounceGC.stopAnimation();
                    bounceGC.playAnimation(0, 6000)},
      f2:function(){bounceGC.pauseAnimation()},
      f3:function(){bounceGC.stepAnimation()},
      f4:function(){bounceGC.stopAnimation()}
    };

  </script>

  <script type="text/javascript">
    addLoadEvent( function(){
      buildMenu(indexData);
      robotArmDemo('cgArm2');
      drawShapes('cg2');
      editCurve('cgDrag');
      drawPaths('cgSvg');
      dragArm('cgArm');
      beachBallDemo('ball');
      bouncingBallDemo('bounce');
      enableStickyNav();
    });
  </script>

</head>
<body>
<center> all data copied from <a href="http://www.arc.id.au/">http://www.arc.id.au/</a> for educational use only. </center><br /><br />
  <div id="headerBkg"></div>
  <div class="outer">
    <div class="header">
      <p class="banner" style="z-index:1">MISCELLANY</p>
       <p class="hdrBlurb">MISCELLANEOUS TECHNICAL ARTICLES BY <span style="letter-spacing: 1px;">Dr</span> A R COLLINS</p> 
      <div id="logoHolder" style="">
        <p class="banner inverse">MISCELLANY</p>
      </div>
      <div id="logo">
        <a class="logoText" href="index.htm"><b>arc</b><br/><span style="font-size:14px">.id.au</span></a>
      </div>
    </div>

    <div id="sideNavBkg"></div>
    <div id="sideNav" class="sticky">
      <!--
            filled by 'buildMenu()'
      -->
    </div>      <!-- sideNav -->

    <div id="page">
      <div id="content">
        <div class="h1Bkg"></div>
        <h1>Cango2D</h1>
        <div class="text_01">

<h2>Cango2D canvas animation library</h2>
<p>Cango2D is a JavaScript graphics library for general drawing and animation on a canvas element. The current version of Cango2D is 7v01, and the source code is available at <a href="Cango2D-7v01.js" download>Cango2D-7v01.js</a>. The <a href="Cango2DUserGuide.html">Cango2D&nbsp;User&nbsp;Guide</a> has a description of all the Cango2D methods.</p>

<p>A note of caution, the Cango2D library is still evolving, if a method would be more efficient with different parameters, they are changed. So users should take care in assuming backward compatibility when a new version is released. Version 7 makes significant simplifications to the API so code written for earlier versions may require modification to run with the Version 7. All the changes and new features are documented in the <a href="Cango2DUserGuide.html">Cango2D&nbsp;User&nbsp;Guide</a>.</p>

<h3>New in Cango2D Version 7</h3>
<ul>
<li>
<p>In version 7v00 the Tweener interpolation object was been generalized to support an array of key times to match its key frame values. The keyTimes were expressed as a fraction of the Tweener timeline duration. Version 7v01 expects the key time values to be expressed as a <b>percentage</b> of the duration interval. They must be a monotonically increasing array of values in the range 0 to 100.</p>
</li>
</ul>


<p>Cango2D borrows much of its API from the <a href='CanvasGraphics.html'>Cango</a> library but its internal architecture is targeted at animation based on matrix transforms and transform inheritance. Cango2D has a simple architecture, all items to be drawn on the canvas are instances of the Obj2D object, whether they are path outlines, filled shapes, text or images. These objects can have arbitrary translation, rotation and scaling applied with the effects accumulating. They can be collected into groups by adding them to Group2D objects which can have both Obj2D and more Group2D as children. All can be animated, all can have drag-and-drop enabled.</p>

<h3>Animation example demonstrating inherited movement</h3>
<p>The power of the Group2D passing on any transforms to its children and the children then adding any transforms that have had applied to them and in turn passing on the net effect, can be demonstrated in the following example. Figure 1 shows an articulated arm with several jointed segments, successive segments inherit the movement applied to the previous segments to which they add their own movement.</p>

<div class="consoleHolder">
  <div class="console">
    <div class="bezel">

    <div class="scrnBevel" >
      <canvas id="cgArm2" width="640" height="400" style="background-color: lightyellow;"></canvas>
    </div>  <!-- scrnBevel -->

    <table class="btnHolder" cellspacing="0" cellpadding="0">
      <tr align="center">
        <td width="25%"><button type="button" onclick="consoleBtns1.f1()" class="button-link">RUN</button></td>
        <td width="25%"><button type="button" onclick="consoleBtns1.f2()" class="button-link">PAUSE</button></td>
        <td width="25%"><button type="button" onclick="consoleBtns1.f3()" class="button-link">STEP</button></td>
        <td width="25%"><button type="button" onclick="consoleBtns1.f4()" class="button-link">STOP</button></td>
      </tr>
    </table>

    </div>  <!-- bezel -->
    <div style="clear: both"></div>
  </div> <!-- console -->
</div> <!-- consoleHolder -->

<div class="captionHolder" style="width: 640px">
  <p><b>Figure 1.</b> Example of animating a Group2D which demonstrates child Group2D and Obj2D inheriting the movement of parent groups.</p>
</div>  <!-- captionHolder -->

<h3>Features of <i>Cango2D</i></h3>
<ul style="margin-top:1em">
<li>
<b>World Coordinates</b> - Drawing is all in a user defined X,Y coordinate system, X increases to the right and Y increases up the canvas. The X and Y scaling are the same and the world coordinate origin (0,0) may be set anywhere, even off the canvas.
</li>
<li>
<b>Object Oriented</b> - All items drawn with Cango2D are instances of a JavaScript <i>Obj2D</i> object, whether they are PATH, SHAPE, IMG, TEXT or CLIP type. An <i>Obj2D</i> can be rendered and re-rendered onto the canvas with arbitrary translation, scaling and rotation, without having to re-construct the object. Obj2D can be grouped as children of Group2D objects. Group2Ds can have more Group2Ds as children too creating a family tree of objects.
</li>
<li>
<b>Compact SVG like notation</b> - Cango2D uses the Cgo2D format to define object outline paths. Cgo2D borrows the compact SVG 'path' syntax to define path and shape outlines as a series of straight lines or Bézier curves. The Cango2D coordinate system differs from the SVG since SVG Y coordinates increase DOWN the canvas while Cango2D increase UP. SVG path descriptions may still be copied and pasted into application code by using the <b>svgToCgo2D</b> utility to handle the coordinate flip.
</li>
<li>
<b>Shapes</b> - Color filled shapes can be simple, predefined circles, triangles and squares etc. or any complex shapes specified in the SVG path syntax. Gradient color fills are supported. Shapes may comprise sub-paths with user control of their winding direction, so shapes can have cut-out effects.
</li>
<li>
<b>Text</b> - Text may be positioned in world coordinates with 9 default alignment options with arbitrary rotation and variable font size and weight.
</li>
<li>
<b>Images</b> - Images can be loaded as HTML Image objects or loaded from a URL reference and rendered with arbitrary positioning, scaling and rotation with 9 default internal drawing origins for easy alignment.
</li>
<li>
<b>Drag and Drop</b> - Both Group2Ds and Obj2Ds can be enabled for drag-n-drop. All the event handling support code is built-in, applications just specify the callback functions.
</li>
<li>
<p><b>Matrix Transforms</b> - The positioning, scaling an rotation of all objects is handled by matrix transforms. Both Obj2D and Group2D have a <b>transform</b> property whose 'translate', 'rotate', 'revolve', 'skew' and 'scale' methods create the matrix transforms and save them to be applied when the object is next rendered. The transform.bend method differs somewhat in that it applies different movement to each node depending on its distance from the object's drawing origin.</p>
</li>
<li>
<p><b>Animation</b> - Any Obj2D or Group2D can have transform movements and property values animated. Animation uses a Timeline model where each animated object has user defined <b>initFn</b> and <b>pathFn</b> functions. The initFn sets the initial state of the object prior to animation starting. The pathFn applies transforms and sets property values such as position, rotation color for each frame.</p>

<p>A Cango2D context may have multiple objects animated. Animations may be on different layers over a background canvas. These are all run simultaneously from the same master timeline. So all animations have each frame drawn simultaneously. Each pathFn has independent control of its object's frame to frame behaviour, so objects may have independent delay and looping behaviour. All path functions are passed the same time stamp for each frame ensuring simple animation synchronization.</p>

<p>For animations where the next frame state depends on the state of the previous fame the <b>currState</b> and <b>nextState</b> objects are maintained and available to path functions.</p>

<p>Cango2D provides the <b>Tweener</b> utility for path functions that calculate frame to frame movement by interpolating between key frame values.</p>
</li>

<li>
<p><b>Drop Shadows and Borders</b> - All objects can have drop shadow effects applied and SHAPE, TEXT and IMG type objects can have contrasting colored borders.</p>
</li>
</ul>

<h3>Using <i>Cango2D</i>.</h3>
<p>To use the Cango2D in a web page, download the JavaScript file: <a href="Cango2D-7v01-min.js" download>Cango2D-7v01-min.js</a>. Store the file in a directory accessible to JavaScript code running in the web page, then add the following line to the web page header:</p>
<div class="srcFmt">
<pre>
&lt;script type="text/javascript" src="<i>directory-path</i>/Cango2D-7v01-min.js"&gt;&lt;/script&gt;
</pre>
</div>
<p>Within the body of the web page insert a canvas element. The only attribute required by Cango2D is a unique <b>id</b>.</p>
<div class="srcFmt">
<pre>
&lt;canvas id="<i>canvasID</i>" width="500" height="300"&gt;&lt;/canvas&gt;
</pre>
</div>
<p>Cango2D resets the pixel dimensions of its canvas element to match the HTML canvas box dimensions, forcing a 1:1 mapping of canvas pixels to screen pixels. Cango2D uses isotropic scaling, X and Y scaling are the same, pixels are 'square'.</p>

<h4>The <i>Cango2D</i> drawing context</h4>
<p>Each graphics context is an instance of the <i>Cango2D</i> object, with its own set of properties such as world coordinate system scaling factors, default values for font size, stroke color and so on. Multiple <i>Cango2D</i> instances may exist simultaneously on the same canvas, each having its own properties. Each contexts world coordinate system covers the entire canavs. Drawing calls to a different contexts may be interspersed without affecting any other Cango2D context settings. A Cango2D graphics context is created by passing the target canvas element's ID property to the Cango2D constructor as follows:</p>
<div class="srcFmt">
<pre>
var g = new Cango2D('<i>canvasID</i>');
</pre>
</div>
<p>The returned object <b>g</b>, has the <i>Cango2D</i> drawing methods such as g.<b>setWorldCoords</b>, g.<b>drawPath</b>, g.<b>render</b> and so on.</p>
<p>Here is the simplest example of a web page using Cango2D:</p>
<div class="srcFmt">
<pre>
&lt;!DOCTYPE HTML>
&lt;html>
&lt;head>
  &lt;title>Cango2D Test&lt;/title>
  &lt;script type="text/javascript" src="Cango2D-7v01-min.js">&lt;/script>
  &lt;script type="text/javascript">
    function sayHullo(cvsID)
    {
      var g = new Cango2D(cvsID);
      g.setWorldCoords(0, 0, 10);     // 0,0 at lower left, canvas 10 unit wide
      g.drawText("Hullo World", 5, 4, {fillColor:'red', fontSize:36, lorg:5});
    }
  &lt;/script>
&lt;/head>
&lt;body onload="sayHullo('cvs1')">
  &lt;canvas id="cvs1" width="300" height="200" style="background-color: lightyellow">&lt;/canvas>
&lt;/body>
&lt;/html>
</pre>
</div>

<h3>Cango2D Basic Drawing</h3>

<p>Cango2D shares the same basic drawing principles as Cango library.</p>
<p>Fig 2 shows basic drawing capabilities of Cango2D.</p>

  <canvas id="cg2" class="cvsEg" width="500" height="350"></canvas>

<div class="captionHolder" style="width: 600px">
  <p><b>Figure 2.</b> Examples of Bar Chart, Point and Line graph and various shapes.</p>
</div>  <!-- captionHolder -->

<h4>Image handling</h4>
<p>Cango2D can load, draw and animate images just as well as paths and shapes. The Obj2D constructor can take a pre-loaded HTML Image object or the URL of an image file as a parameter. In the case of a URL, the image is loaded into an HTML Image object and rendered in accordance with the user requested size of the image and other properties and with any transform methods applied.</p>

<h4>SVG Path Examples</h4>
<p>Figure 3 shows the SVG <b>path</b> examples from the W3C SVG 1.1 specification at <a href="http://www.w3.org/TR/SVG/paths.html">http://www.w3.org/TR/SVG/paths.html</a>. The path 'd' attribute string has been cut and pasted into a JavaScript string variable which can be converted to the Cgo2D format array using the <b>svgToCgo2D</b> utility function. Here is a code snippet to draw the red trinagle from the SVG test page.</p>

<div class="srcFmt">
<pre>
...
var Triangle = "M 100 100 L 300 100 L 200 300 z";

tri = new Obj2D(svgToCgo2D(Triangle), "SHAPE", {fillColor:'red'});
tri.translate(100, 950);
g.render(tri);
...
</pre>
</div>

  <canvas id="cgSvg" class="cvsEg" width="350" height="350"></canvas>

<div class="captionHolder" style="width: 450px">
  <p class="caption"><b>Figure 3.</b> Example of the using externally generated SVG path definitions for drawing shapes and paths.</p>
</div>  <!-- captionHolder -->

<h4>Drag and Drop</h4>
<p>Drag-and-Drop capability can be enabled and disabled on any Obj2D or Group2D by <i>obj</i>.<b>enableDrag</b> and <i>obj</i>.<b>disableDrag</b> methods. The 'enableDrag' method takes as a parameters the callback functions that are to be run when mousedown, mousemove and mouseup events occur. The callbacks are passed the current cursor coordinates when called. They are executed in the scope of a <i>Drag2D</i> object which, for convenience, has various properties such as <b>grabCsrPos</b>, <b>dwgOrg</b>, <b>dwgOrgOfs</b>, <b>grabOfs</b> and so on, to assist in simple coding of event handlers. Enabling drag-n-drop on a Group2D recursively enables the drag-n-drop on all the group's children.</p>
<p>Here is a simple example, which shows two Bézier curves with draggable control points.</p>

<canvas id="cgDrag" class="cvsEg" width="450" height="300"></canvas>

<div class="captionHolder" style="width: 450px">
  <p class="caption"><b>Figure 4.</b> Example of drag-n-drop on the red circle SHAPE Obj2D.</p>
</div>  <!-- captionHolder -->

<p>The code for the curve editor in Fig. 4 is show below.</p>
<div class="srcFmt">
<pre>
function editCurve(cvsID)
{
  var x1 = 40, y1 = 20,
      cx1 = 90, cy1 = 120,
      x2 = 120, y2 = 100,
      cx2 = 130, cy2 = 20,
      cx3 = 150, cy3 = 120,
      x3 = 180, y3 = 60,
      c1, c2, c3,
      g = new Cango2D(cvsID);

  function dragC1(mousePos)    // called in scope of dragNdrop obj
  {
    cx1 = mousePos.x;
    cy1 = mousePos.y;
    drawCurve();
  }

  function dragC2(mousePos)
  {
    cx2 = mousePos.x;
    cy2 = mousePos.y;
    drawCurve();
  }

  function dragC3(mousePos)
  {
    cx3 = mousePos.x;
    cy3 = mousePos.y;
    drawCurve();
  }

  function drawCurve()
  {
    var qbez, cbez,
        grp,
        L1, L2, L3;
    // curve change shape so it must be re-constructed each time
    // draw a quadratic bezier from x1,y2 to x2,y2
    qbez = new Obj2D(['M', x1, y1, 'Q', cx1, cy1, x2, y2], "PATH", {
      strokeColor:'blue'});
    cbez = new Obj2D(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], "PATH", {
      strokeColor:'green'});
    // show lines to control point
    L1 = new Obj2D(['M', x1, y1, 'L', cx1, cy1, x2, y2], "PATH", {
      strokeColor:"rgba(0, 0, 0, 0.2)",
      dashed:[4]});   // semi-transparent gray
    L2 = new Obj2D(['M', x2, y2, 'L', cx2, cy2], "PATH", {
      strokeColor:"rgba(0, 0, 0, 0.2)",
      dashed:[4]});
    L3 = new Obj2D(['M', x3, y3, 'L', cx3, cy3], "PATH", {
      strokeColor:"rgba(0, 0, 0, 0.2)",
      dashed:[4]});
    // draw draggable control points
    c1.transform.translate(cx1, cy1);
    c2.transform.translate(cx2, cy2);
    c3.transform.translate(cx3, cy3);
    grp = g.createGroup2D(qbez, cbez, L1, L2, L3, c1, c2, c3);
    g.clearCanvas();
    g.render(grp);
  }

  g.clearCanvas("lightyellow");
  g.setWorldCoords(0, 0, 200);

  // draggable control points
  c1 = new Obj2D(shapeDefs.circle(4), "SHAPE", {fillColor:'red'});
  c1.enableDrag(null, dragC1, null);

  c2 = c1.dup();
  c2.enableDrag(null, dragC2, null);

  c3 = c1.dup();
  c3.enableDrag(null, dragC3, null);

  drawCurve();
}
</pre>
</div>

<h3>Drag and Drop using Group2Ds</h3>
<p>The Group2D object simplifies coding complex animation and drag and drop applications. Group2D objects have a 'children' array which holds Obj2D or more Group2D objects. Any transform applied to the Group2D object is inherited by the children. If any of the children are themselves Group2D then it's children will inherit from both the parent and grand parent and so on down a family tree. A good example of the power of Grouping is the robot arm shown in Fig.&nbsp;5. Each segment is a Group2D with has as children a SHAPE type Obj2D, which is the arm, a circle SHAPE Obj2D which is the axle and a Group2D which is the next segment.</p>

<p>When a segment is dragged the arm rotates relative to its parent segment and all its children (and their children) rotate with it. Click and drag a segment and try it.</p>

<canvas id="cgArm" class="cvsEg" width="600" height="400"></canvas>

<div class="captionHolder" style="width: 600px">
  <p class="caption"><b>Figure 5.</b> Example of drag-n-drop on Group2D objects, children of the Group2D inherit the parent movement transforms.</p>
</div>  <!-- captionHolder -->

<p>The grab and drag event handler code for the arm segments in Fig. 5 is show below.</p>
<div class="srcFmt" style="max-height:580px">
<pre>
...
function segGrab(mousePos)
{
  // this=drag2D, this.target=Obj2D or Group2D being dragged
  var segGrp = this.target,
      csrX = mousePos.x - this.dwgOrg.x,
      csrY = mousePos.y - this.dwgOrg.y;

  segGrp.grabOfsAng = Math.atan2(csrY, csrX) - segGrp.angle;    // all angles in radians
}

function seg1Drag(mousePos)
{
  var segGrp = this.target,
      csrX = mousePos.x - this.dwgOrg.x,
      csrY = mousePos.y - this.dwgOrg.y;

  segGrp.angle = Math.atan2(csrY, csrX) - segGrp.grabOfsAng;   // save angle as a property
  if (segGrp.angle > Math.PI/2)
  {
    segGrp.angle = Math.PI/2;
  }
  else if (segGrp.angle &lt; 0)
  {
    segGrp.angle = 0;
  }

  seg1Grp.transform.rotate(seg1Grp.angle*180/Math.PI);
  seg2Grp.transform.rotate(seg2Grp.angle*180/Math.PI);
  seg2Grp.transform.translate(50,0);
  seg3Grp.transform.rotate(seg3Grp.angle*180/Math.PI);
  seg3Grp.transform.translate(50,0);
  seg4.transform.rotate(seg4.angle*180/Math.PI);
  seg4.transform.translate(50,0);

  g.render(armGrp, true);
}

function segDrag(mousePos)
{
  var segGrp = this.target,
      csrX = mousePos.x - this.dwgOrg.x,
      csrY = mousePos.y - this.dwgOrg.y;

  segGrp.angle = Math.atan2(csrY, csrX) - segGrp.grabOfsAng;   // save angle as a property
  if (segGrp.angle > Math.PI/2)
  {
    segGrp.angle = Math.PI/2;
  }
  else if (segGrp.angle &lt; -Math.PI/2)
  {
    segGrp.angle = -Math.PI/2;
  }

  seg1Grp.transform.rotate(seg1Grp.angle*180/Math.PI);
  seg2Grp.transform.rotate(seg2Grp.angle*180/Math.PI);
  seg2Grp.transform.translate(50,0);
  seg3Grp.transform.rotate(seg3Grp.angle*180/Math.PI);
  seg3Grp.transform.translate(50,0);
  seg4.transform.rotate(seg4.angle*180/Math.PI);
  seg4.transform.translate(50,0);

  g.render(armGrp, true);
}
...
// set up the drag handlers
// give each segment its own 'grabOfsAng' property to save the state
// seg4 is an Obj2D no group needed (its got no children)
seg4.grabOfsAng = 0;
seg4.enableDrag(segGrab, segDrag, null);
// order of enabling drag is import to let children drag independently
seg3Grp.grabOfsAng = 0;
seg3Grp.enableDrag(segGrab, segDrag, null);
seg2Grp.grabOfsAng = 0;
seg2Grp.enableDrag(segGrab, segDrag, null);
seg1Grp.grabOfsAng = 0;
seg1Grp.enableDrag(segGrab, seg1Drag, null); // seg1Grp drag doesn't have the x=50 translation

g.render(armGrp, true);
</pre>
</div>

<h3>Animation using Tweener interpolation</h3>
<p>Shown below is a beach ball is drawn from three objects, a white circle, a red shape drawn in Inkscape from several Bézier curve segments, and a semi-transparent circle overlay providing the radial gradient shading. The ball's position, scale and rotation are all set to loop continuously. The animation can be played, stopped, paused or stepped.</p>

<div class="consoleHolder">
  <div class="console">
    <div class="bezel">

    <div class="scrnBevel" >
      <canvas id="ball" width="600" height="250" style="background-color: lightyellow;"></canvas>
    </div>  <!-- scrnBevel -->

    <table class="btnHolder" cellspacing="0" cellpadding="0">
      <tr align="center">
        <td width="25%"><button type="button" onclick="consoleBtns2.f1()" class="button-link">RUN</button></td>
        <td width="25%"><button type="button" onclick="consoleBtns2.f2()" class="button-link">PAUSE</button></td>
        <td width="25%"><button type="button" onclick="consoleBtns2.f3()" class="button-link">STEP</button></td>
        <td width="25%"><button type="button" onclick="consoleBtns2.f4()" class="button-link">STOP</button></td>
      </tr>
    </table>

    </div>  <!-- bezel -->
    <div style="clear: both"></div>
  </div> <!-- console -->
</div> <!-- consoleHolder -->


<p><br>Here is the code snippet that sets up the rolling beachball animation shown above.</p>
<div class="srcFmt">
<pre>
function beachBallDemo(cvsID)
{
  var circle = "M 534.29,274.5 A 165.7,165.7 0 1 1 202.9,274.5 165.7,165.7 0 1 1 534.3,274.5 z",
      stripes = "M 279.1,134.7 C 260,193.8 318.1,303.8 349.5,343.8 338.3,349.3 330.3,357.9 331.1,372.0 282.5,369.2 232.8,353.1 207.3,313.1 220.9,367.5 258.7,410.6 312,430.4 331.1,419.5 336.5,412.9 349.8,395.6 361.7,401.3 377.6,400.1 388.6,394.2 404.8,411.9 414.6,420.0 433.6,427 482.7,405.2 518.4,364.5 530.7,309.3 508.9,343.1 462.8,363.7 404.7,369.4 404.1,356.7 396.1,348.5 384.8,343.2 426.2,276 460.9,182 451.8,130.9 393.8,98.6 330.4,103 279.1,134.7 z",
      xRef = 368.57,  // this is the reference point expressed in Inkscape coords
      yRef = 274.5,
      dia = 2*165.7,
      ballData, ball,
      panelsData, panels,
      shade, shading, shadows,
      beachball,
      twnr,
      ballConfig = {x:[1100, 150, 1100],
                    y:[300, 200, 300],
                    scl:[0.6, 1, 0.6],
                    rot:[0, 360, 0],
                    delay:0,
                    duration:3500,
                    loop:'loop' };

  twnr = new Tweener(ballConfig.delay, ballConfig.duration, ballConfig.loop);

  function initBall(opts)
  {
    this.obj.transform.translate(1100, 300);
    this.obj.transform.scale(0.6);
  }

  function ballPathFn(time, opts)
  {
    var sclVal = twnr.getVal(time, opts.scl),
        xVal = twnr.getVal(time, opts.x),
        yVal = twnr.getVal(time, opts.y),
        rotVal = twnr.getVal(time, opts.rot);

    this.obj.transform.scale(sclVal);
    this.obj.transform.rotate(rotVal);
    this.obj.transform.translate(xVal, yVal);
  }

  function shadePathFn(time, opts)
  {
    var sclVal = twnr.getVal(time, opts.scl),
        xVal = twnr.getVal(time, opts.x),
        yVal = twnr.getVal(time, opts.y);

    this.obj.transform.scale(sclVal);
    this.obj.transform.translate(xVal, yVal);
  }

  ballGC = new Cango2D(cvsID);
  ballGC.setWorldCoords(0, 0, 1200); // square pixels

  ballData = svgToCgo2D(circle, -xRef, -yRef);
  ball = new Obj2D(ballData, "SHAPE", {fillColor:"ghostwhite"});

  panelsData = svgToCgo2D(stripes, -xRef, -yRef);
  panels = new Obj2D(panelsData, "SHAPE", {fillColor:"red"});

  shadows = sphereShading(dia),
  shade = new Obj2D(shapeDefs.circle(dia), "SHAPE", {fillColor:shadows.shadow});
  ballHilite = new Obj2D(shapeDefs.circle(dia), "SHAPE", {fillColor:shadows.hilite});

  beachball = ballGC.createGroup2D(ball, panels);
  shading = ballGC.createGroup2D(shade, ballHilite);

  ballGC.animate(beachball, initBall, ballPathFn, ballConfig);
  ballGC.animate(shading, initBall, shadePathFn, ballConfig);

//  ballGC.playAnimation();
}
</pre>
</div>

<h3>Animation using currState/nextState</h3>
<p>Shown below is an animation of a bouncing ball. Each frame depending on the previous state of the ball, its position and velocity and the time since the last frame was drawn. Newton laws of motion will dictate that the ball should continue tomove according to it svelocity vecotr but added to this is the accelleration due to gravity and the collisions with the boundary walls. Saving the state vector in nextState object means that it will be available as currSate when the pathFn is called for the next frame. The time a frame is drawn is always mainatained in currState.time and the time at which the pathFn is called is padded as a parameter to the pathFn. Clicking "RESTART" will re-launch the ball at a random angle.</p>

<div class="consoleHolder">
  <div class="console">
    <div class="bezel">

    <div class="scrnBevel" >
      <canvas id="bounce" width="600" height="400" style="background-color: lightyellow;"></canvas>
    </div>  <!-- scrnBevel -->

    <table class="btnHolder" cellspacing="0" cellpadding="0">
      <tr align="center">
        <td width="25%"><button type="button" onclick="consoleBtns3.f1()" class="button-link">RESTART</button></td>
        <td width="25%"><button type="button" onclick="consoleBtns3.f2()" class="button-link">PAUSE</button></td>
        <td width="25%"><button type="button" onclick="consoleBtns3.f3()" class="button-link">STEP</button></td>
        <td width="25%"><button type="button" onclick="consoleBtns3.f4()" class="button-link">STOP</button></td>
      </tr>
    </table>

    </div>  <!-- bezel -->
    <div style="clear: both"></div>
  </div> <!-- console -->
</div> <!-- consoleHolder -->


<p><br>Here is the code snippet that sets up the rolling beachball animation shown above.</p>
<div class="srcFmt">
<pre>
var bounceGC;           // Cango2D graphics context

function initBall(opts)
{
  // create any properties you want in nextState, currState will be a clone
  // don't write to currState its just there for reference to what is on the screen
  this.nextState.x = 120;
  this.nextState.y = 250;
  this.nextState.vx = 0;
  this.nextState.vy = 0;

  this.obj.transform.translate(this.nextState.x, this.nextState.y);
}

function bouncingPath(time, opts)    // time passed is the time since start of animation
{
  // 'this' refers to the Animation object (this.obj, this.gc, this.nextState etc)
  // currState is avaliable for reference to what is on the screen (don't write to it)
  // after obj is drawn in nextState, nextState and currState are swapped
  var reflect = -1,     // bounce off wall else disappear
      coeff = 0.82,     // percentage bounce height (superball)
      friction = 0.985, // rolling friction loss/msec
      speed = 1.5,      // units are like worldCoords x axis units/mm
      gravity = -0.0098 * speed, // gravity =9.8m/s/s =0.0098mm/ms/ms =0.0098*speed units/ms/ms
      xVel = 0,
      yVel = 0,
      x, y,
      vel, startAngle, timeInt, s, u;

  if (time == 0)   // generate random launch angle for each reset
  {
    // restart at a random angle
    // velocity in 2m/s = 2 mm/ms = 2mm/ms * units/mm = 2*speed
    vel = 2*speed;    // x units/ms
    startAngle = 30+120*Math.random();
    this.nextState.x = 120;           // put ball back at the start point
    this.nextState.y = 250;
    this.nextState.vx = vel * Math.cos(startAngle * Math.PI / 180);
    this.nextState.vy = vel * Math.sin(startAngle * Math.PI / 180);

    this.obj.transform.translate(this.nextState.x, this.nextState.y);
    return;     // this is the state to get drawn at start
  }
  // calculate the new position and velocity
  timeInt = time - this.currState.time;   // time since last draw
  // v = u + at
  yVel = this.currState.vy + gravity * timeInt;    // accelerating due to gravity
  xVel = this.currState.vx;                    // constant
  x = this.currState.x + xVel*timeInt;
  y = this.currState.y + yVel*timeInt + 0.5*gravity * timeInt * timeInt;
   // now check for hitting the walls
  if (x > opts.rightWall - opts.radius)
  {
    x = opts.rightWall - opts.radius;
    xVel *= reflect*coeff;    // lossy reflection next step
  }
  if (x &lt; opts.leftWall + opts.radius)
  {
    x = opts.leftWall + opts.radius;
    xVel *= reflect*coeff;    // lossy reflection next step
  }
  if (y > opts.topWall - opts.radius)
  {
    y = opts.topWall - opts.radius;
    yVel *= reflect*coeff;    // lossy reflection next step
  }
  if (y &lt; opts.bottomWall + opts.radius)  // this is always true after yVel become small
  {
    y = opts.bottomWall + opts.radius;
    // calc velocity at the floor   (v^2 = u^2 + 2*g*s)
    s = this.currState.y - (opts.bottomWall + opts.radius);     // pre bounce
    u = this.currState.vy;
    yVel = -Math.sqrt(u*u - 2*gravity*s);
    yVel *= reflect*coeff;  // lossy reflection next step
    // after bouncing phase this is rolling friction
    xVel *= friction;
  }
  this.nextState.x = x;
  this.nextState.y = y;
  this.nextState.vx = xVel;
  this.nextState.vy = yVel;

  this.obj.transform.translate(this.nextState.x, this.nextState.y); // move to next position
}

function bouncingBallDemo(cvsID)
{
  var shadows,
      ball, shade, ballHilite,
      ballGrp,
      dia = 45;

  shadows = sphereShading(dia, 255, 0, 0);   // red ball (r=500, g=0, b=0)

  ball = new Obj2D(shapeDefs.circle(dia), "SHAPE", {fillColor:shadows.base} );
  shade = new Obj2D(shapeDefs.circle(dia), "SHAPE", {fillColor:shadows.shadow});
  ballHilite = new Obj2D(shapeDefs.circle(dia), "SHAPE", {fillColor:shadows.hilite});

  bounceGC = new Cango2D(cvsID);
  bounceGC.setWorldCoords();      // use raw pixels

  ballGrp = bounceGC.createGroup2D(ball, shade, ballHilite);
  bounceGC.animate(ballGrp, initBall, bouncingPath, { radius:dia/2,
                                                      leftWall:0,
                                                      rightWall:bounceGC.rawWidth,
                                                      topWall:bounceGC.rawHeight,
                                                      bottomWall:0 });
}
</pre>
</div>

        </div>  <!-- text_01 -->
      </div>   <!--  content -->
    </div>  <!-- page  -->

  </div>   <!-- outer -->

</body>
</html>