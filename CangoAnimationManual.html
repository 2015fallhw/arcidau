<!DOCTYPE HTML>
<html>
<head>
  <title>Cango Animation Module User Guide</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="keywords" content="canvas graphics, canavs animation, Cango, Cango animation extension, canvas graphics library modules" />

  <link rel="stylesheet" href="2ColStickyScroll-14.css" media="all" type="text/css" />
  <style type="text/css" media="screen">
    @import "contentStyle-18.css";
    @import "console-43.css";
    @import "userManual-01.css";
    @import "horizontalMenu-09.css";

    .demoWrapper {
      width: 400px;
      position:relative;
      margin:2em auto 3em auto;
    }

    #cvs1 {
      background-color: lightyellow;
      border: 1px solid black;
    }

    #cvs2 {
      background-color: #404040;
      border: 1px solid black;
    }
  </style>

  <script type="text/javascript">
    var sidebar = null,
        sidebar_top = 100;

    if (typeof addLoadEvent === "undefined")
    {
      var addLoadEvent = function(func)
      {
      	var oldonload = window.onload;
      	if (typeof window.onload != 'function')
        {
          window.onload = func;
        }
      	else
        {
        	window.onload = function(){oldonload();	func();}
        }
      }
    }

    if (typeof addEvent === "undefined")
    {
      var addEvent = function(element, eventType, handler)
      {
        if (element.attachEvent)
        {
          return element.attachEvent('on'+eventType, handler);
        }
        return element.addEventListener(eventType, handler, false);
      };
    }

    function cancelBubble(e)
    {
      var evt = e ? e:window.event;
      if (evt.stopPropagation) evt.stopPropagation();
      if (evt.cancelBubble!=null) evt.cancelBubble = true;
    }

    /* -------------------------------------------------------------------------
     * buildMenu(dataArray)
     *
     * dataArray should be in JSON format as follows
     * [ {"url":"url of file", "title":"String to display in index"},
     *   {"url":"url of file", "title":"String to display in index",
     *    "chapters": [
     *       {"url":"url of file", "title":"String to display in index"},
     *       {"url":"url of file", "title":"String to display in index"},
     *       ...
     *       {"url":"url of file", "title":"String to display in index"}
     *     ]
     *   },
     *   {"url":"url of file", "title":"String to display in index"},
     *   ...
     * ]
     * Then build HTML anchors from the array.
     *--------------------------------------------------------------------------*/
    function buildMenu(dataArray)
    {
      var menuNode = document.getElementById("sideNav"),
          htmlStr = "",
          currPage,
          i;

      function subStringReplaceAt(str, index, newSubStr, oldSubStrLength)
      {
        return str.slice(0, index) + newSubStr + str.slice(index+oldSubStrLength);
      }

      function parseAry(obj)
      {
        var currPage = document.URL.replace(/^.*[\\\/]/, ''),   // split off the page name (cross platform)
            i;
        for (i=0; i<obj.length; i++)
        {
          if (obj[i].chapters)
          {
            htmlStr += "<ul>";
            htmlStr += "<li class='sectClosed'><input type='button' onclick='toggleSection(this)' value='"+obj[i].title+"'><ul class='options'>";
            parseAry(obj[i].chapters);
            htmlStr += "</ul></li>";
          }
          else
          {
            htmlStr += "<li><a href='"+obj[i].url+"' target='_top'>"+obj[i].title+"</a></li>";
            // check if this index entry is the current page, if open this section to show link
            if (currPage == obj[i].url)
            {
              htmlStr = subStringReplaceAt(htmlStr, htmlStr.lastIndexOf("sectClosed"), "sectOpen", 10);
            }
          }
        }
      }

      parseAry(dataArray);
      menuNode.innerHTML += htmlStr;
    }

    function toggleSection(btn)
    {
      if (btn && btn.parentNode.className === "sectClosed")
      {
        btn.parentNode.className = "sectOpen";
      }
      else if (btn && btn.parentNode.className === "sectOpen")
      {
        btn.parentNode.className = "sectClosed";
      }
      return false;   // is used with anchor will prevent going to href
    }

    function enableStickyNav()
    {
      var stickyElements = document.getElementsByClassName('sticky');

      for (var i = stickyElements.length - 1; i >= 0; i--) {
          Stickyfill.add(stickyElements[i]);
      }
    }
  </script>

<!-- 'indexNested.js' defines the global 'var indexData' holding menu entries  -->
  <script type="text/javascript" src="indexNested.js"></script>
  <script src="stickyfill.js"></script>

  <script type="text/javascript" src="Cango-8v03-min.js"></script>
  <script type="text/javascript" src="CangoAnimation-4v01.js"></script>
  <script type="text/javascript" src="flintlockOuterParts-01.js"></script>

  <script type="text/javascript">

    var ballGC;           // ball graphics context
    function orbitDemo(cvsID)
    {
      var ball = new Cobj(shapeDefs.circle(40), "SHAPE", {fillColor:"royalblue"});
      var ballData = {cx:150, cy:120, radius:80, va:1.5, ang:0};

      function initBall(opts)
      {
        this.nextState.x = opts.cx+opts.radius;
        this.nextState.y = opts.cy;
      }

      function orbit(time, opts)
      {
        var dt = time - this.currState.time;      // time since last frame

        opts.ang += opts.va*dt/1000;     // angle moved at constant angular velocity
        if (opts.ang > 2*Math.PI)        // wraparound for angle
        {
          opts.ang -= 2*Math.PI;
        }
        this.nextState.x = opts.cx + opts.radius * Math.cos(opts.ang);  // calculate coords of ball
        this.nextState.y = opts.cy + opts.radius * Math.sin(opts.ang);
      }

      ballGC = new Cango(cvsID);
      ballGC.setGridboxRHC();     // whole canvas
      ballGC.setWorldCoords();    // square pixels

      ballGC.animate(ball, initBall, orbit, ballData );

      ballGC.playAnimation();
    }


//========================================================================================

    var moonGC;

    function moonDemo(cvsID, moonImg)
    {
      var xmin = -200,
          ymin = -140,
          xspan = 400,
          moon,
          shadow,
          clipCircle,
          diameter = 150,
          percentFull = 30;

      moon = new Cobj(moonImg, "IMG", {imgWidth: diameter, lorg: 5} );
      clipCircle = new Cobj(shapeDefs.circle(diameter), "PATH");

      // plot
      moonGC = new Cango(cvsID),
      moonGC.clearCanvas();
      moonGC.setGridboxRHC(15, 5, 75);  // data area, units are % of canvas width
      moonGC.setWorldCoords(xmin, ymin, 400);

      function initShadow(opts)
      {
        var hx = (50-percentFull)/100,
            d = diameter;

        var shadowDef = ["m", 0, 0.5*d,
              "c", -0.27614*d,0, -0.5*d,-0.22386*d, -0.5*d,-0.5*d,
              "c", 0,-0.27614*d, 0.22386*d,-0.5*d, 0.5*d,-0.5*d,
              "c", 0.5523*hx*d,0, hx*d,0.22386*d, hx*d,0.5*d,
              "c", 0,0.27614*d, -0.4477*hx*d,0.5*d, -hx*d,0.5*d];

        this.obj[1] = new Cobj(shadowDef, "SHAPE", {
          fillColor:'rgba(0,0,0,0.4)',
          shadowOffsetX: 2,      // rotate offsetX = 2 by 135 deg
          shadowOffsetY: 0,
          shadowBlur: 7,
          shadowColor: "rgba(0,0,0,0.9)"} );
        moonGC.clipPath(clipCircle);

        this.nextState.hx = hx;      // save it for next frame
        this.nextState.d = d;
      }

      function shadowPath(time, opts)
      {
        var dt = time - this.currState.time,
            sgn = Math.sign(this.currState.d),    // 1 = waning moon, -1 = waxing
            hx = this.currState.hx + sgn*0.005,
            shadowDef,
            d;

        if (hx > 0.5)
        {
          hx = 0.5;
          this.currState.d *= -1;   // flip dark crescent from left to right (or right to left)
        }
        if (hx < -0.5)
        {
          hx = -0.5;
          this.currState.d *= -1;   // flip dark crescent from left to right (or right to left)
        }
        d = this.currState.d;

        shadowDef = [ "m", 0, 0.5*d,
                      "c", -0.27614*d,0, -0.5*d,-0.22386*d, -0.5*d,-0.5*d,
                      "c", 0,-0.27614*d, 0.22386*d,-0.5*d, 0.5*d,-0.5*d,
                      "c", 0.5523*hx*d,0, hx*d,0.22386*d, hx*d,0.5*d,
                      "c", 0,0.27614*d, -0.4477*hx*d,0.5*d, -hx*d,0.5*d ];

        this.obj[1] = new Cobj(shadowDef, "SHAPE", {
          fillColor:'rgba(0,0,0,0.4)',
          shadowOffsetX: Math.sign(d)*2,      //offsetX = 2 (left or right)
          shadowOffsetY: 0,
          shadowBlur: 7,
          shadowColor: "rgba(0,0,0,0.9)"} );
        moonGC.clipPath(clipCircle);

        this.nextState.hx = hx;  // save it for next frame
        this.nextState.d = d;
      }

      moonGC.animate([moon, shadow], initShadow, shadowPath, {} );
    }
//========================================================================================

    function enableBtn(btnId)
    {
      var btn = document.getElementById(btnId);
      btn.disabled = false;
    }

    function disableBtn(btnId)
    {
      var btn = document.getElementById(btnId);
      btn.disabled = true;
    }

    function FlintlockDemo(cvsL)
    {
      "use strict"
      var outerGC,
          // Lock components (Cango2D groups)
          plateOutside,
          cockOutside,
          fizzenOutside,
          fizzenSpring,
          outScrews;

      this.fire_JS = function()
  		{
        outerGC.playAnimation(0, 1000);

        disableBtn('cock');
        disableBtn('fire');
        setTimeout("enableBtn('load')", 1000);
      };

      this.load_JS = function()
      {
        outerGC.playAnimation(1000, 3500);

        disableBtn('load');
        disableBtn('fire');
        setTimeout("enableBtn('cock')", 2500);

      };

      this.cock_JS = function()
      {
        outerGC.playAnimation(3500, 5000);

        disableBtn('load');
        disableBtn('cock');
        setTimeout("enableBtn('fire')", 1500);
      };

      // Lower display
      outerGC = new Cango(cvsL);
      outerGC.setWorldCoords(-250, -100, 500);

      // construct all the component objects
      plateOutside = makePlateOutside(outerGC);
      cockOutside = makeCockOutside(outerGC);
      fizzenOutside = makeFizzenOutside(outerGC);
      fizzenSpring = makeFizzenSpring(outerGC);
      outScrews = makeOutScrews(outerGC);

			var outerTwnr = new Tweener(0, 5000);
      var outerData = {
    	  outerCockRot:     [0, -54, -54, -18, -18,  0],
        outerCockRotTimes:[0,  10,  20,  60,  70, 90],
        outerFizRot:     [0, 0, -73, -73,  0],
        outerFizRotTimes:[0, 4,   8,  60, 70],
        outerFizSpringRot:     [0, 0, 5, 6, 3.5, 0,  0,    3,  4,    3,  0],
        outerFizSpringRotTimes:[0, 4, 5, 6,   7, 8, 60, 62.5, 65, 67.5, 70]
      };

      function initCockOutside(opts)
      {
        this.nextState.x = -cockCxOfs;
        this.nextState.y = -cockCyOfs;
      }

      function initFissenOutside(opts)
      {
        this.nextState.x = -fizzenCxOfs;
        this.nextState.y = -fizzenCyOfs;
      }

      function initFissenSpring(opts)
      {
        this.nextState.x = -fizzenSpringCxOfs;
        this.nextState.y = -fizzenSpringCyOfs;
      }

      function outerCockPathFn(time, opts)
      {
        var cockRotVal = outerTwnr.getVal(time, opts.outerCockRot, opts.outerCockRotTimes);

        this.nextState.rot = cockRotVal;
      }

      function outerFizzenPathFn(time, opts)
      {
        var fizzenRotVal = outerTwnr.getVal(time, opts.outerFizRot, opts.outerFizRotTimes);

        this.nextState.rot = fizzenRotVal;
      }

      function fizzenSpringPathFn(time, opts)
      {
        var fizSpgRotVal = outerTwnr.getVal(time, opts.outerFizSpringRot, opts.outerFizSpringRotTimes);

        this.nextState.rot = fizSpgRotVal;
      }

      outerGC.animate(plateOutside);
			outerGC.animate(cockOutside, initCockOutside, outerCockPathFn, outerData);
      outerGC.animate(fizzenOutside, initFissenOutside, outerFizzenPathFn, outerData);
      outerGC.animate(fizzenSpring, initFissenSpring, fizzenSpringPathFn, outerData);
      outerGC.animate(outScrews);

      disableBtn('load');
      disableBtn('cock');
      enableBtn('fire');
    }

    var consoleBtns =
    {
      f1:function(){lockDemo.load_JS()},
      f2:function(){lockDemo.cock_JS()},
      f3:function(){lockDemo.fire_JS()}
    };

  </script>


 <script type="text/javascript">
    addLoadEvent( function(){
      buildMenu(indexData);
      enableStickyNav();

      orbitDemo('cvs1');

      var moonPic = new Image();   // when animating Images always pre-loaded Image
      addEvent(moonPic, 'load', function(){moonDemo('cvs2', moonPic);});
      moonPic.src = "Images/moon-04-transparent-337x337.png";      // start loading

      lockDemo = new FlintlockDemo('cvs3');
    });
  </script>

</head>

<body>
<center> all data copied from <a href="http://www.arc.id.au/">http://www.arc.id.au/</a> for educational use only. </center><br /><br />
  <div id="headerBkg"></div>
  <div class="outer">
    <div class="header">
      <p class="banner" style="z-index:1">MISCELLANY</p>
       <p class="hdrBlurb">MISCELLANEOUS TECHNICAL ARTICLES BY <span style="letter-spacing: 1px;">Dr</span> A R COLLINS</p> 
      <div id="logoHolder" style="">
        <p class="banner inverse">MISCELLANY</p>
      </div>
      <div id="logo">
        <a class="logoText" href="index.html"><b>arc</b><br/><span style="font-size:14px">.id.au</span></a>
      </div>
    </div>

    <div id="sideNavBkg"></div>
    <div id="sideNav" class="sticky">
      <!--
            filled by 'buildMenu()'
      -->
    </div>      <!-- sideNav -->

    <div id="page">
      <div id="content">
        <div class="h1Bkg"></div>
        <h1>Cango Animation Module User Guide</h1>
        <div class="text_01">

<h2>Cango animation extension</h2>
<p>The Cango Animation extension module <a href="CangoAnimation-4v01.js" download>CangoAnimation-4v01.js</a> provides additional methods to the Cango library to support animating any or all of an Cobj position, size and rotation. Version 4 requires Cango-8v00 or greater. The Cango methods added by this module are:</p>

<p><a href="#animate">animate</a>, <br/>
<a href="#playAnimation">playAnimation</a>,<br/>
<a href="#pauseAnimation">pauseAnimation</a>,<br/>
<a href="#stepAnimation">stepAnimation</a>,<br/>
<a href="#stopAnimation">stopAnimation</a>,<br/>
<a href="#redrawAnimation">redrawAnimation</a>,<br/>
<a href="#deleteAnimation">deleteAnimation</a>,<br/>
<a href="#deleteAllAnimations">deleteAllAnimations</a>.</p>

<p>The module also supplies a global path generator 'Tweener' which may be used by animation path functions for simple interpolate between keyframe values.</p>

<p>An animation is defined by a call to <i>cgo</i>.<b>animate</b> passing the Cobj (or array of Cobj) to be animated along with references to an initialization function 'initFn', to set things up and a path function 'pathFn', to calculate the position, scale and rotation of the object for each frame along the timeline and an 'options' object which can hold any user defined properties that may be required or just useful to the initFn and the pathFn.</p>

<p>A Cango context may have multiple objects animated, these are all run simultaneously from the same timeline. The 'playAnimation', 'pauseAnimation', 'stepAnimation' and 'stopAnimation' methods control the motion along the timeline. At each frame the canvas layer on which the object is to be drawn will be cleared and each animated object drawn in its new position, size and orientation as specified in the <b>nextState</b> object.</p>

<p>If a Cango context has created several canvas layers then all the objects on all the layers work off the same timeline.</p>
<p>Multiple animations may be defined for this graphics context, all will start, stop, step and pause together.</p>

<p>To remove the object and its animation specification use 'deleteAnimation' or 'deleteAllAnimations' methods.</p>

<p>The animation frame rate is set by the 'requestAnimationFrame' utility, the time between frames will not be constant but will generally be around 17 msec (~60 frames/second).</p>


<h3>Simple animation example</h3>
<p>Here is a simple example of animating an object to travel in a circle to show the methods at work.</p>

<div class="demoWrapper" style="width: 350px">
          <canvas id="cvs1" width="350" height="250"></canvas>
          <div class="horizMenuRgt">
            <ul>
             <li>
                <a href="#" onclick="ballGC.pauseAnimation();return false">Pause</a>
              </li>
              <li>
                <a href="#" onclick="ballGC.playAnimation();return false">Start</a>
              </li>
            </ul>
          </div> <!-- botMenuRgt -->
  </div>

<p>Here is the example source code.</p>

<div class="srcFmt" style="max-height:550px">
<pre>var ballGC;
function orbitDemo(cvsID) {
  var ball,
      orbitVals = {cx:150, cy:120, radius:80, va:1.5, ang:0};  // use as 'options'

  ballGC = new Cango(cvsID);
  ballGC.setGridboxRHC();   // whole canvas
  ballGC.setWorldCoords();  // square pixels

  ball = new Cobj(shapeDefs.circle(40), "SHAPE", {fillColor:"royalblue"});

  function initBall(opts) {
    this.nextState.x = opts.cx+opts.radius;
    this.nextState.y = opts.cy;
  }

  function orbit(time, opts) {
    var dt = time - this.currState.time;      // time since last frame

    opts.ang += opts.va*dt/1000;     // angle moved at constant angular velocity 'va'
    if (opts.ang > 2*Math.PI)        // wraparound for angle
    {
      opts.ang -= 2*Math.PI;
    }
    this.nextState.x = opts.cx + opts.radius * Math.cos(opts.ang);  // new coords of ball
    this.nextState.y = opts.cy + opts.radius * Math.sin(opts.ang);
  }

  ballGC.animate(ball, initBall, orbit, orbitVals);
}</pre>
</div>


<h3>Animation model</h3>
<p>Any object can be animated by calling the <i>Cango</i>.<b>animate</b> method passing as parameters references to 'obj', the Cobj to be animated, along with references to user defined functions 'initFn', and 'pathFn'. An 'options' object can also be passed which can hold any user defined data that will be useful to these initFn and pathFn. The <b>initFn</b> function is called immediately to allow user code to initialize any of the object properties. If the state of the object depend on its state in the previous frame then the initFn should assign initial values to the 'nextState' object and if required create additional properties of 'nextState'. The 'obj' is rendered immediately after initFn is called using the 'this.nextState' values. Once the animation is started by a call to 'playAnimation' or 'stepAnimation', the <b>pathFn</b> function is called immediately prior to the rendering the 'obj' onto the canvas at each frame of the animation. The pathFn receives the elapsed time along the timeline as an argument, using this pathFn can generate the 'nextState' properties x, y, scl, and rot as required and update any other user defined properties such as velocity or acceleration. The render method will be called on this object with these nextState x, y, scl, and rot properties as arguments. Since the pathFn is called immediately after the canvas is cleared and before render is called, the pathFn may call Cango context, 'this.gc', methods to modify any of the Cango properties or the lower level 'this.gc.ctx' properties. The canvas context is saved prior to calling pathFn and restored after the render so any changes to the canvas drawing context only affect the single frame.</p>

<h3 id="Animation">The Animation object</h3>
<p>To implement this animation model, the Cango <b>animate</b> method creates a JavaScript object of type <b>Animation</b> which encapsulates references to the object to be animated, the Cango context to render the object and state properties and so on. The <b>initFn</b> and the <b>pathFn</b> are called in the scope of the Animation object ie. within these functions 'this' will refer to the Animation object so all its properties, particularly the 'nextState' object, are readily available.</p>

<h4>Properties:</h4>

<p><b style="color:blue">gc</b>: Cango graphics context - the graphics context that will render the object onto the canvas at each frame along the timeline. The pathFn can make use of this graphics context to call Cango methods such as clipPath or setDefaultProperty etc.</p>

<p><b style="color:blue">obj</b>: Cobj or array of Cobj - the Cobj object (or array of Cobj) to be animated. Having access to the object to be rendered gives complete control to the initFn and the pathFn. For example the pathFn may create a new Cobj for each frame and have the new object drawn by simply assigning this.obj to a new Cobj (or array of Cobj).</p>

<p><b style="color:blue">nextState</b>: Object - An object is created with the basic properties x, y, scl, and rot, with default values 0,0,1,0 respectively. These basic property values may be updated by the pathFn prior to drawing each frame of the animation the values are then passed to the render function as arguments. The initFn code may add any properties that may be useful to save the state of the animation between frames. Once the render function has been called the nextState is swapped with the currState object so the 'as rendered' values of the properties are available to the pathFn as a reference for the next time it is called when it will overwrite the nextState values with new values for the next frame and so on.</p>

<p><b style="color:blue">currState</b>: Object - An object created as a copy of the nextState vector after initFn is called. This object should be considered read-only as it will be swapped with the nextFrame object after each frame is rendered. This frees all the nextState properties to be over-written but preserves their values which were used to draw the frame currently on screen.</p>

<p><b style="color:blue">options</b>: Object - An object that is available the initFn and pathFn to hold values useful in generating the nextState typically used to store constants and parameters for predefined pathFns such as 'interpolate'. The interpolate function uses options object to specify which of x, y, scl, rot are to be interpolated, and the keyframe values and timing.</p>

<hr class="ugHr" />

<h2>Cango methods added by the Animation module</h2>

<div class="manualItems">

<div class="sectClosed">
  <a id="animate" href="#" class="itemName" onclick="return toggleSection(this)">animate</a>
  <dt class="itemBody">
<h4>Syntax:</h4>
<p class='syntax'>animId = <i>cgo</i><b>.animate</b>(obj, initFn, pathFn, options);</p>
<h4>Description:</h4>
<p>The animate method creates an Animation object with properties that make everything required to control the animation available to the initFn and pathFn. Both these functions are called in the scope of this Animation object.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'>obj: Cobj or array of Cobj - the Cobj object (or array of Cobj) to be animated.</p>
<p style='margin-left:2em'>initFn: Function - A function to be called to initialize or create additional properties of nextState (if required).</p>
<p style='margin-left:2em'>pathFn: Function - A function to be called to update the nextState properties to the values to be used when drawing the next frame. When called pathFn is passed two parameters 'time' and the 'options' object. The time will be in the same format as 'this.currState.time so that the elapsed time since the last frame was drawn will be:
<pre>
var dt = time - this.currState.time;  // in miliseconds
</pre>
</p>
<p style='margin-left:2em'>options: Object - An object storing any variables or constants that may be required by the initFn, or pathFn. The options object is passed as an argument to these functions.</p>
  </dt>
</div>

<div class="sectClosed">
  <a id="deleteAnimation" href="#" class="itemName" onclick="return toggleSection(this)">deleteAnimation</a>
  <dt class="itemBody">
<h4>Syntax:</h4>
<p class='syntax'><i>cgo</i><b>.deleteAnimation</b>(animId);</p>
<h4>Description:</h4>
<p>All animations are paused and the animation whose ID is 'animId' is deleted. This ID value was returned when the animation was created by a call to 'animate' method. The animation definition is removed from the current array of animations. The animated object will remain frozen in the state drawn in the last frame. This method may be called on any Cango context on any layer in the stack and will still delete the nominated animation.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'>animId: String - An ID string returned when the animation was created.</p>
  </dt>
</div>

<div class="sectClosed">
  <a id="deleteAllAnimations" href="#" class="itemName" onclick="return toggleSection(this)">deleteAllAnimations</a>
  <dt class="itemBody">
<h4>Syntax:</h4>
<p class='syntax'><i>cgo</i><b>.deleteAllAnimations</b>();</p>
<h4>Description:</h4>
<p>Deletes all the animations from the background layer and from any and all canvas layers. All the animations are stopped and animation definitions removed from the current array of animations, all the animated objects will remain frozen where they were last drawn. This method may be called on any Cango context on any layer and will still clear all animations on all layers.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'>none.</p>
  </dt>
</div>

<div class="sectClosed">
  <a id="playAnimation" href="#" class="itemName" onclick="return toggleSection(this)">playAnimation</a>
  <dt class="itemBody">
<h4>Syntax:</h4>
<p class='syntax'><i>cgo</i><b>.playAnimation</b>([startTime[, stopTime]]);</p>
<h4>Description:</h4>
<p>Starts all animations that have been defined for Cango contexts on this canvas (or stack of canvases if overlay canvases have been created). At each frame the elapsed time along the timeline is passed to the pathFn so it can configure the properties of the object being animated. By default, the timeline is traversed from time 0, but if a 'startTime' is passed then this will be the time initially passed to the pathFn. The animation timeline is traversed by drawing a frame and then making a call to 'requestAnimationFrame' to draw the next and so on until the 'stopAnimation' method is called or, if a 'stopTime' was passed then the animation will stop as soon as the time equals or exceeds this stopTime.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'>startTime: Number - Optional time in milliseconds along the timeline where the animation playing will commence.</p>
<p style='margin-left:2em'>stopTime: Number - Optional time in milliseconds along the timeline where the animation will cease and the mode will be set to 'stopped'.</p>
  </dt>
</div>

<div class="sectClosed">
  <a id="pauseAnimation" href="#" class="itemName" onclick="return toggleSection(this)">pauseAnimation</a>
  <dt class="itemBody">
<h4>Syntax:</h4>
<p class='syntax'><i>cgo</i><b>.pauseAnimation</b>();</p>
<h4>Description:</h4>
<p>Stops any current animation on the canvas and remembers where along the timeline it was paused. When 'playAnimation' or 'stepAnimation' are called the animation will resume from the current position along the timeline. This differs from the 'stopAnimation' call which forces the animation to return to the start when playAnimation or stepAnimation are called.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'>none.</p>
  </dt>
</div>

<div class="sectClosed">
  <a id="redrawAnimation" href="#" class="itemName" onclick="return toggleSection(this)">redrawAnimation</a>
  <dt class="itemBody">
<h4>Syntax:</h4>
<p class='syntax'><i>cgo</i><b>.redrawAnimation</b>();</p>
<h4>Description:</h4>
<p>If the animation is in 'paused' or 'stopped' modes then the animation will be re-drawn with the 'currState' object properties. The timeline is not advanced. After the frame is drawn animation will remain in the 'paused' or 'stopped' mode. This method is useful for replacing the scene should the canvas be re-sized (and so the drawing cleared) or the basic Cango context properties such as x or y scaling be changed. If the animation is currently in 'play' mode this call is ignored.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'>none.</p>
  </dt>
</div>

<div class="sectClosed">
  <a id="stepAnimation" href="#" class="itemName" onclick="return toggleSection(this)">stepAnimation</a>
  <dt class="itemBody">
<h4>Syntax:</h4>
<p class='syntax'><i>cgo</i><b>.stepAnimation</b>();</p>
<h4>Description:</h4>
<p>If the animation is in 'paused' or 'stopped' modes then the animation will advance by the current value of the <i>cgo</i>.stepTime property (default stepTime is 50 msec), one frame will be drawn at this time and the animation put in the 'paused' mode. If the animation is currently in 'play' mode this call is ignored.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'>none.</p>
  </dt>
</div>

<div class="sectClosed">
  <a id="stopAnimation" href="#" class="itemName" onclick="return toggleSection(this)">stopAnimation</a>
  <dt class="itemBody">
<h4>Syntax:</h4>
<p class='syntax'><i>cgo</i><b>.stopAnimation</b>();</p>
<h4>Description:</h4>
<p>Stops any current animation on the canvas. When 'playAnimation' or 'stepAnimation' are called the animation will resume from the beginning of the animation timeline. This differs from the 'pauseAnimation' call which restart the animation from the current elapsed time along the timeline.</p>
<h4>Parameters:</h4>
<p style='margin-left:2em'>none.</p>
  </dt>
</div>

</div>    <!--  manualItems  -->


<h3>Moon Phases Animation</h3>
<p>Here is a further example that exercises many of the features of Cango animation module. In this example none of the standard x,y,scl or rot values are animated instead the actual Cobj to be rendered is changed at every call to the pathFn. Among the points to note:</p>
<p>The object being animated is an array of two Cobj. The first is of type IMG and hold the picture of the full moon. The second is a SHAPE type Cobj that is filled with semi transparent black color and represents the area of the moon out of direct sunlight.</p>
<p>The outline path of the shadow Cobj is recalculated for every frame. The new Cobj is substituted for the second element of the array of objects to be rendered.</p>
<p>The feathered edge of the shaded area is drawn with a drop shadow. To prevent the drop shadow spreading outside the moon limb cgo.clipPath method is called by the pathFn immediately before the scene is rendered. The animation module resets the clipPath and restores the canvas drawing context to the state existing prior to the pathFn call after every frame.</p>

<div class="demoWrapper" style="width: 350px">
          <canvas id="cvs2" width="350" height="250"></canvas>
          <div class="horizMenuRgt">
            <ul>
             <li>
                <a href="#" onclick="moonGC.pauseAnimation();return false">Pause</a>
              </li>
              <li>
                <a href="#" onclick="moonGC.playAnimation();return false">Start</a>
              </li>
            </ul>
          </div> <!-- botMenuRgt -->
  </div>

<p>Here is the source code.</p>

<div class="srcFmt" style="max-height:550px">
<pre>
function moonDemo(cvsID, moonImg)
{
  var xmin = -200,
      ymin = -140,
      xspan = 400,
      moon,
      shadow,
      clipCircle,
      diameter = 150,
      percentFull = 30;

  moon = new Cobj(moonImg, "IMG", {imgWidth: diameter, lorg: 5} );
  clipCircle = new Cobj(shapeDefs.circle(diameter), "PATH");

  // plot
  moonGC = new Cango(cvsID),
  moonGC.clearCanvas();
  moonGC.setGridboxRHC(15, 5, 75);  // data area, units are % of canvas width
  moonGC.setWorldCoords(xmin, ymin, 400);

  function initShadow(opts)
  {
    var hx = (50-percentFull)/100,
        d = diameter;

    var shadowDef = ["m", 0, 0.5*d,
          "c", -0.27614*d,0, -0.5*d,-0.22386*d, -0.5*d,-0.5*d,
          "c", 0,-0.27614*d, 0.22386*d,-0.5*d, 0.5*d,-0.5*d,
          "c", 0.5523*hx*d,0, hx*d,0.22386*d, hx*d,0.5*d,
          "c", 0,0.27614*d, -0.4477*hx*d,0.5*d, -hx*d,0.5*d];

    this.obj[1] = new Cobj(shadowDef, "SHAPE", {
      fillColor:'rgba(0,0,0,0.4)',
      shadowOffsetX: 2,      // rotate offsetX = 2 by 135 deg
      shadowOffsetY: 0,
      shadowBlur: 7,
      shadowColor: "rgba(0,0,0,0.9)"} );
    moonGC.clipPath(clipCircle);

    this.nextState.hx = hx;      // save it for next frame
    this.nextState.d = d;
  }

  function shadowPath(time, opts)
  {
    var dt = time - this.currState.time,
        sgn = Math.sign(this.currState.d),    // 1 = waning moon, -1 = waxing
        hx = this.currState.hx + sgn*0.005,
        shadowDef,
        d;

    if (hx > 0.5)
    {
      hx = 0.5;
      this.currState.d *= -1;   // flip dark crescent from left to right (or right to left)
    }
    if (hx &lt; -0.5)
    {
      hx = -0.5;
      this.currState.d *= -1;   // flip dark crescent from left to right (or right to left)
    }
    d = this.currState.d;

    shadowDef = [ "m", 0, 0.5*d,
                  "c", -0.27614*d,0, -0.5*d,-0.22386*d, -0.5*d,-0.5*d,
                  "c", 0,-0.27614*d, 0.22386*d,-0.5*d, 0.5*d,-0.5*d,
                  "c", 0.5523*hx*d,0, hx*d,0.22386*d, hx*d,0.5*d,
                  "c", 0,0.27614*d, -0.4477*hx*d,0.5*d, -hx*d,0.5*d ];

    this.obj[1] = new Cobj(shadowDef, "SHAPE", {
      fillColor:'rgba(0,0,0,0.4)',
      shadowOffsetX: Math.sign(d)*2,      //offsetX = 2 (left or right)
      shadowOffsetY: 0,
      shadowBlur: 7,
      shadowColor: "rgba(0,0,0,0.9)"} );
    moonGC.clipPath(clipCircle);

    this.nextState.hx = hx;  // save it for next frame
    this.nextState.d = d;
  }

  moonGC.animate([moon, shadow], initShadow, shadowPath, {} );
}
</pre>
</div>

<hr class="ugHr" />

<h2 id="tweener">Tweener interpolation utility</h2>

<p>When writing a Cango animation 'pathFn' functions, the aim is to generate values of position, scale and rotation or some style property that can be set for the object being animated. New values need to be generated for each frame so the 'pathFn' is called prior to each frame. If the property is specified as an array of key values then the next frame values can be obtained by interpolating between these keyframe values. The <b>Tweener</b> object is provided to simplify this task. A Tweener holds the basic parameters of a timeline and has just one method: <b>getVal</b> which will do the interpolation calculations based on key frame values and the next frame time along the timeline.</p>

<h3>Tweener constructor</h3>
<h4>Syntax:</h4>
<p class='syntax'>var twnr  = <b>new Tweener</b>(delay, dur, loopStr);</p>
<h4>Description:</h4>
<p>This utility is provided to simplify interpolation between elements in an array of key values. Creating a Tweener object sets up a timeline of length 'dur' milliseconds which optional 'delay' to the start of the animation and whether the animation repeats specified by the 'loop' parameter.</p>
<p>NOTE: The constructor should not be called inside a path function, this would create a new timeline at every frame effectively restarting the interpolation every time.</p>

<h4>Parameters:</h4>
<p style='margin-left:2em'><b>delay</b>:Number - A time in milliseconds that must be exceeded before interpolating key values begins. When a Cango animation is started by a call to the 'playAnimation' method times starting at 0 msec are passed to path functions.</p>
<p style='margin-left:2em'><b>dur</b>:Number - The duration of the animation starting after 'delay' milliseconds and lasting 'dur' milliseconds. Interpolated values will be returned for time between delay msec and delay+dur msec.</p>
<p style='margin-left:2em'><b>loopStr</b>:String - The 'loopStr' parameter can take two values that will cause animation looping: 'loop' and 'loopAll'. After the initial delay (if delay is non-zero) 'loop' will cause the animated sequence that is 'dur' msec long to be repeated without repeating the delay. 'loopAll' will cause the delay and the animation to repeat, so the repeat interval will be delay+dur msec long. Either value will repeat its sequence indefinitely or until 'stopAnimation' or 'pauseAnimation' stops more calls being made to animation path functions. If the delay = 0 there is no difference in behaviour between 'loop' and 'loopAll'.</p>

<h3>Tweener methods</h3>
<div class="manualItems">
<div class="sectOpen">
  <a id="getval" href="" class="itemName" onclick="return false;" style="background-image:none">getVal</a>
  <dt class="itemBody">
<h4>Syntax:</h4>
<p class='syntax'>var val = twnr.<b>getVal</b>(time, keyValues[, keyTimes]);</p>
<h4>Description:</h4>
<p>The <b>getVal</b> method is designed to be used in an animation pathFn which will be called immediately prior to each animation frame being rendered. It returns a value for some property at time 'time' along a timeline of duration twnr.dur by interpolating between elements in an array of key values. The keyframe values are specified in the <b>keyValues</b> array. It is assumed that the first key value represents the property at the beginning of the Tweener timeline 'dur' period and the last key value is the value at the end of 'dur' period.</p>

<p>The key frame times corresponding to the key values may be passed to 'getVal' in a separate <b>keyTimes</b> array. If no 'keyTimes' array is passed to the 'getVal' method then the key values are assumed to be equally spaced over the 'dur' time.</p>

<h4>Parameters:</h4>
<p style='margin-left:2em'><b>time</b>:Number - Elapsed time along the Tweener timeline, measured in milliseconds when getVal is called. The value starts at 0 and continues incrementing until <i>Cango</i>.<b>stopAnimation</b> is called, which will reset the elapsed time to 0. The 'getVal' method will not start interpolating until the time exceeds the Tweener 'delay' time. It then commences interpolating the value of the properties based on the time elapsed since starting as a percentage of the 'duration' parameter. The animation will last for 'dur' milliseconds. It will continue to return the last keyValue for all times exceeding delay+dur unless the timeline has looping enabled.</p>

<p style='margin-left:2em'><b>keyValues</b>:Number or Array of Numbers - A single number will represent the static value for the entire animation. If 'keyValues' is an array then its elements represent the key values in the animation. If the array of values has 2 or more elements, the first will be the initial value returned after time 'delay' milliseconds. The last value will be the value at the finish of the animation after time interval 'delay+dur'.</p>

<p style='margin-left:2em'><b>keyTimes</b>:Array of Numbers - An array holding the keyframe times corresponding to the keyValues. The 'keyTimes' array must have the same number of elements as the 'keyValues' array. Time values are specified as a percentage of the Tweener.dur property so the values are limited to the range 0 to 100. If keyTimes is undefined then the key values are assumed to be equally spaced over the 'dur' time.</p>
  </dt>
</div>
</div>  <!-- manualItems -->

<!-- ==============================================================================================   -->

<h3>Interpolate example</h3>
<p>Here is an animation of a flintlock mechanism demonstrating the use of the supplied Tweener utility. It also demonstrates the use of playAnimation <b>startTime</b> and <b>stopTime</b> parameters. The parts have one common timeline but using different startTime and stopTime values three different sections of the timeline can be played as separate animations.</p>

<div class="consoleHolder">
  <div class="console">
    <div class="bezel">

    <div class="scrnBevel" >
      <canvas id="cvs3" width="640" height="300"></canvas>
    </div>  <!-- scrnBevel -->

    <table class="btnHolder" cellspacing="0" cellpadding="0">
      <tr align="center">
        <td width="33%"><button onclick="consoleBtns.f1()" type="button" class="button-link" id="load">HALF COCK</button></td>
        <td width="33%"><button onclick="consoleBtns.f2()" type="button" class="button-link" id="cock">COCK</button></td>
        <td width="33%"><button onclick="consoleBtns.f3()" type="button" class="button-link" id="fire">FIRE</button></td>
      </tr>
    </table>

    </div>  <!-- bezel -->
    <div style="clear: both"></div>
  </div> <!-- console -->
</div> <!-- consoleHolder -->

<p>Here are the relevant source code snippets.</p>

<div class="srcFmt" style="max-height:550px">
<pre>
...
var outerTwnr = new Tweener(0, 5000);
var outerData = {
 outerCockRot:     [0, -54, -54, -18, -18,  0],
  outerCockRotTimes:[0,  10,  20,  60,  70, 90],
  outerFizRot:     [0, 0, -73, -73,  0],
  outerFizRotTimes:[0, 4,   8,  60, 70],
  outerFizSpringRot:     [0, 0, 5, 6, 3.5, 0,  0,    3,  4,    3,  0],
  outerFizSpringRotTimes:[0, 4, 5, 6,   7, 8, 60, 62.5, 65, 67.5, 70]
};

function initCockOutside(opts)
{
  this.nextState.x = -cockCxOfs;
  this.nextState.y = -cockCyOfs;
}

function initFissenOutside(opts)
{
  this.nextState.x = -fizzenCxOfs;
  this.nextState.y = -fizzenCyOfs;
}

function initFissenSpring(opts)
{
  this.nextState.x = -fizzenSpringCxOfs;
  this.nextState.y = -fizzenSpringCyOfs;
}

function outerCockPathFn(time, opts)
{
  var cockRotVal = outerTwnr.getVal(time, opts.outerCockRot, opts.outerCockRotTimes);

  this.nextState.rot = cockRotVal;
}

function outerFizzenPathFn(time, opts)
{
  var fizzenRotVal = outerTwnr.getVal(time, opts.outerFizRot, opts.outerFizRotTimes);

  this.nextState.rot = fizzenRotVal;
}

function fizzenSpringPathFn(time, opts)
{
  var fizSpgRotVal = outerTwnr.getVal(time, opts.outerFizSpringRot, opts.outerFizSpringRotTimes);

  this.nextState.rot = fizSpgRotVal;
}

outerGC.animate(plateOutside);
outerGC.animate(cockOutside, initCockOutside, outerCockPathFn, outerData);
outerGC.animate(fizzenOutside, initFissenOutside, outerFizzenPathFn, outerData);
outerGC.animate(fizzenSpring, initFissenSpring, fizzenSpringPathFn, outerData);
outerGC.animate(outScrews);
</pre>
</div>

<h4>Points to note:</h4>
<p>The 'plateOutside' and the 'outScrews' are static objects and may be drawn just once on the background canvas and an overlay canvas with the moving parts drawn on a separate layer. Drawing everything on the one layer is also possible as demonstrated here. The static objects like these can be redrawn every frame by calling animate on the Cobj with no pathFn function, they will just be re-drawn for every frame in the same default location or in the state set by initFn.</p>

        </div>  <!-- text_01 -->
      </div>   <!--  content -->
    </div>  <!-- page  -->

  </div>   <!-- outer -->

</body>
</html>